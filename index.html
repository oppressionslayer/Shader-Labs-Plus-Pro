<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shader Lab Pro+ | Icosahedron Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --accent-primary: #00ff88;
            --accent-secondary: #ff3366;
            --accent-tertiary: #00e5ff;
            --bg-dark: #0a0a0f;
            --bg-panel: rgba(15, 15, 25, 0.95);
            --text-primary: #ffffff;
            --text-secondary: #888899;
            --border-color: rgba(255, 255, 255, 0.1);
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 380px;
            min-height: 100vh;
            gap: 0;
        }

        @media (max-width: 1000px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: 60vh auto;
            }
        }

        /* Canvas Section */
        .canvas-section {
            position: relative;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #shaderCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .canvas-overlay {
            position: absolute;
            top: 15px;
            left: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .badge {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 8px 14px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            border: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .badge-live {
            color: var(--accent-primary);
        }

        .audio-control {
            cursor: pointer;
            background: rgba(255, 50, 100, 0.3);
            border: 1px solid rgba(255, 50, 100, 0.5);
            transition: all 0.3s ease;
        }

        .audio-control:hover {
            background: rgba(255, 50, 100, 0.5);
            transform: scale(1.05);
        }

        .audio-control.playing {
            background: rgba(50, 255, 150, 0.3);
            border: 1px solid rgba(50, 255, 150, 0.5);
            color: #50ff96;
        }

        .audio-control.playing:hover {
            background: rgba(50, 255, 150, 0.5);
        }

        .badge-live::before {
            content: '';
            width: 8px;
            height: 8px;
            background: var(--accent-primary);
            border-radius: 50%;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        .fps-counter {
            color: var(--accent-tertiary);
        }

        /* Control Panel */
        .control-panel {
            background: var(--bg-panel);
            border-left: 1px solid var(--border-color);
            overflow-y: auto;
            max-height: 100vh;
        }

        .panel-header {
            padding: 20px;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(255, 51, 102, 0.1));
            border-bottom: 1px solid var(--border-color);
            position: sticky;
            top: 0;
            z-index: 10;
            backdrop-filter: blur(20px);
        }

        .panel-title {
            font-size: 22px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-tertiary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .panel-subtitle {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        /* Sections */
        .section {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .section-title {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-secondary);
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .section-title::before {
            content: '';
            width: 3px;
            height: 12px;
            background: var(--accent-primary);
            border-radius: 2px;
        }

        /* Shader Selector */
        .shader-select {
            width: 100%;
            padding: 12px 15px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 14px;
            cursor: pointer;
            outline: none;
            transition: all 0.3s ease;
        }

        .shader-select:hover {
            border-color: var(--accent-primary);
            background: rgba(0, 255, 136, 0.05);
        }

        .shader-select option {
            background: var(--bg-dark);
            padding: 10px;
        }

        /* Presets Grid */
        .presets-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .preset-btn {
            padding: 10px 8px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-secondary);
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .preset-btn:hover {
            background: rgba(0, 255, 136, 0.1);
            border-color: var(--accent-primary);
            color: var(--text-primary);
        }

        .preset-btn.active {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 229, 255, 0.2));
            border-color: var(--accent-primary);
            color: var(--accent-primary);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.2);
        }

        .preset-btn.disabled {
            text-decoration: line-through;
            text-decoration-color: #ff3333;
            color: #666;
            cursor: not-allowed;
            opacity: 0.5;
            pointer-events: none;
        }

        /* Slider Control */
        .slider-control {
            margin-bottom: 18px;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .slider-label {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .slider-value {
            font-size: 12px;
            color: var(--accent-tertiary);
            font-weight: 600;
            font-family: 'Consolas', monospace;
        }

        .slider-track {
            position: relative;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .slider-fill {
            position: absolute;
            height: 100%;
            background: linear-gradient(90deg, var(--accent-primary), var(--accent-tertiary));
            border-radius: 3px;
            transition: width 0.1s ease;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
            position: relative;
            z-index: 2;
            margin-top: -6px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            transition: transform 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--accent-primary);
            border-radius: 50%;
            border: none;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }

        /* Color Picker */
        .color-control {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .color-picker-wrapper {
            position: relative;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid var(--border-color);
            transition: border-color 0.3s ease;
        }

        .color-picker-wrapper:hover {
            border-color: var(--accent-primary);
        }

        input[type="color"] {
            width: 60px;
            height: 60px;
            border: none;
            cursor: pointer;
            position: absolute;
            top: -10px;
            left: -10px;
        }

        .color-label {
            font-size: 12px;
            color: var(--text-secondary);
            flex: 1;
        }

        .color-hex {
            font-size: 11px;
            color: var(--accent-tertiary);
            font-family: 'Consolas', monospace;
        }

        /* Buttons */
        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn {
            flex: 1;
            padding: 12px 16px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-tertiary));
            color: var(--bg-dark);
            border: none;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 255, 136, 0.3);
        }

        .btn-secondary {
            background: transparent;
            color: var(--text-primary);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: var(--accent-primary);
        }

        /* Toggle Switch */
        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .toggle-label {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .toggle {
            width: 44px;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .toggle.active {
            background: var(--accent-primary);
        }

        .toggle::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: transform 0.3s ease;
        }

        .toggle.active::after {
            transform: translateX(20px);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 15px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow: hidden;
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            width: 32px;
            height: 32px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 8px;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 18px;
            transition: background 0.3s ease;
        }

        .modal-close:hover {
            background: var(--accent-secondary);
        }

        .modal-body {
            padding: 20px;
            max-height: 55vh;
            overflow-y: auto;
        }

        .code-block {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 15px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            line-height: 1.6;
            color: var(--accent-tertiary);
            white-space: pre-wrap;
            word-break: break-all;
        }

        .modal-footer {
            padding: 15px 20px;
            border-top: 1px solid var(--border-color);
            background: var(--bg-panel);
        }

        .copy-btn {
            width: 100%;
        }

        /* Info text */
        .info-text {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 10px;
            line-height: 1.5;
        }

        /* Keyboard shortcuts */
        kbd {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            font-family: inherit;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="canvas-section">
            <canvas id="shaderCanvas"></canvas>
            <audio id="bgAudio" src="1.mp3" loop preload="auto"></audio>
            <div class="canvas-overlay">
                <div class="badge badge-live">LIVE</div>
                <div class="badge fps-counter" id="fpsCounter">60 FPS</div>
                <div class="badge" id="presetIndicator">Icosahedron | Default</div>
                <div class="badge audio-control" id="audioControl" title="Click to unmute audio">MUTED</div>
            </div>
        </div>

        <div class="control-panel">
            <div class="panel-header">
                <div class="panel-title">Shader Lab Pro+</div>
                <div class="panel-subtitle">Icosahedron Explorer v1.0</div>
            </div>

            <!-- Shader Selection -->
            <div class="section">
                <div class="section-title">Shader</div>
                <select class="shader-select" id="shaderSelect">
                    <option value="0">Fractal Orb</option>
                    <option value="1">Plasma Sphere</option>
                    <option value="2">Icosahedron Spikes</option>
                    <option value="3">Crystal Matrix</option>
                    <option value="4">Neon Wireframe</option>
                    <option value="5">Cyberpunk City</option>
                    <option value="6">Liquid Metal</option>
                    <option value="7">Quantum Flux</option>
                    <option value="8">Void Tendrils</option>
                    <option value="9">Prismatic Storm</option>
                    <option value="10">Biomech Entity</option>
                    <option value="11">Fractal Cosmos</option>
                    <option value="12">Plasma Vortex</option>
                    <option value="13">Neon Boxes</option>
                    <option value="14">Warp Tunnel</option>
                    <option value="15">Hyperdrive</option>
                    <option value="16">Neural Storm</option>
                    <option value="17">Cosmic Singularity</option>
                    <option value="18">Dimensional Rift</option>
                    <option value="19">Stellar Nursery</option>
                    <option value="20">Cyber Grid</option>
                    <option value="21">Liquid Aurora</option>
                    <option value="22">Fractal Flame</option>
                    <option value="23">Quantum Foam</option>
                    <option value="24">Tesseract</option>
                    <option value="25">Digital Rain</option>
                    <option value="26">Nebula Core</option>
                    <option value="27">Crystal Cavern</option>
                    <option value="28">Infinity Mirror</option>
                </select>
            </div>

            <!-- Quick Actions -->
            <div class="section">
                <button class="btn btn-primary" id="randomBtn" style="width: 100%; margin-bottom: 0;">Randomize</button>
            </div>

            <!-- Presets -->
            <div class="section">
                <div class="section-title">Presets</div>
                <div class="presets-grid" id="presetsGrid">
                    <button class="preset-btn active" data-preset="0">Default</button>
                    <button class="preset-btn" data-preset="1">Alien</button>
                    <button class="preset-btn" data-preset="2">Crystal</button>
                    <button class="preset-btn" data-preset="3">Fire</button>
                    <button class="preset-btn" data-preset="4">Ice</button>
                    <button class="preset-btn" data-preset="5">Neon</button>
                    <button class="preset-btn" data-preset="6">Void</button>
                    <button class="preset-btn" data-preset="7">Gold</button>
                    <button class="preset-btn" data-preset="8">Matrix</button>
                </div>
            </div>

            <!-- Animation -->
            <div class="section">
                <div class="section-title">Animation</div>
                <div class="slider-control">
                    <div class="slider-header">
                        <span class="slider-label">Speed</span>
                        <span class="slider-value" id="speedValue">1.00</span>
                    </div>
                    <div class="slider-track"><div class="slider-fill" id="speedFill"></div></div>
                    <input type="range" id="speed" min="0" max="3" step="0.01" value="1">
                </div>
                <div class="slider-control">
                    <div class="slider-header">
                        <span class="slider-label">Time Offset</span>
                        <span class="slider-value" id="timeOffsetValue">0.00</span>
                    </div>
                    <div class="slider-track"><div class="slider-fill" id="timeOffsetFill"></div></div>
                    <input type="range" id="timeOffset" min="0" max="10" step="0.1" value="0">
                </div>
                <div class="toggle-row">
                    <span class="toggle-label">Pause <kbd>SPACE</kbd></span>
                    <div class="toggle" id="pauseToggle"></div>
                </div>
            </div>

            <!-- Camera -->
            <div class="section">
                <div class="section-title">Camera</div>
                <div class="slider-control">
                    <div class="slider-header">
                        <span class="slider-label">Zoom</span>
                        <span class="slider-value" id="zoomValue">4.00</span>
                    </div>
                    <div class="slider-track"><div class="slider-fill" id="zoomFill"></div></div>
                    <input type="range" id="zoom" min="1" max="10" step="0.1" value="4">
                </div>
                <div class="slider-control">
                    <div class="slider-header">
                        <span class="slider-label">FOV</span>
                        <span class="slider-value" id="fovValue">2.00</span>
                    </div>
                    <div class="slider-track"><div class="slider-fill" id="fovFill"></div></div>
                    <input type="range" id="fov" min="0.5" max="5" step="0.1" value="2">
                </div>
                <div class="slider-control">
                    <div class="slider-header">
                        <span class="slider-label">Camera Height</span>
                        <span class="slider-value" id="camHeightValue">1.00</span>
                    </div>
                    <div class="slider-track"><div class="slider-fill" id="camHeightFill"></div></div>
                    <input type="range" id="camHeight" min="0" max="2" step="0.01" value="1">
                </div>
            </div>

            <!-- Geometry -->
            <div class="section" id="geometrySection">
                <div class="section-title">Geometry</div>
                <div class="slider-control">
                    <div class="slider-header">
                        <span class="slider-label">Spike Length</span>
                        <span class="slider-value" id="spikeLengthValue">1.30</span>
                    </div>
                    <div class="slider-track"><div class="slider-fill" id="spikeLengthFill"></div></div>
                    <input type="range" id="spikeLength" min="0" max="3" step="0.01" value="1.3">
                </div>
                <div class="slider-control">
                    <div class="slider-header">
                        <span class="slider-label">Spike Width</span>
                        <span class="slider-value" id="spikeWidthValue">0.05</span>
                    </div>
                    <div class="slider-track"><div class="slider-fill" id="spikeWidthFill"></div></div>
                    <input type="range" id="spikeWidth" min="0.01" max="0.3" step="0.01" value="0.05">
                </div>
                <div class="slider-control">
                    <div class="slider-header">
                        <span class="slider-label">Shell Thickness</span>
                        <span class="slider-value" id="shellThicknessValue">0.03</span>
                    </div>
                    <div class="slider-track"><div class="slider-fill" id="shellThicknessFill"></div></div>
                    <input type="range" id="shellThickness" min="0.01" max="0.2" step="0.005" value="0.03">
                </div>
                <div class="slider-control">
                    <div class="slider-header">
                        <span class="slider-label">Sphere Radius</span>
                        <span class="slider-value" id="sphereRadiusValue">1.00</span>
                    </div>
                    <div class="slider-track"><div class="slider-fill" id="sphereRadiusFill"></div></div>
                    <input type="range" id="sphereRadius" min="0.5" max="2" step="0.01" value="1">
                </div>
                <div class="slider-control">
                    <div class="slider-header">
                        <span class="slider-label">Smoothing</span>
                        <span class="slider-value" id="smoothingValue">0.12</span>
                    </div>
                    <div class="slider-track"><div class="slider-fill" id="smoothingFill"></div></div>
                    <input type="range" id="smoothing" min="0" max="0.5" step="0.01" value="0.12">
                </div>
            </div>

            <!-- Lighting -->
            <div class="section">
                <div class="section-title">Lighting</div>
                <div class="slider-control">
                    <div class="slider-header">
                        <span class="slider-label">Light X</span>
                        <span class="slider-value" id="lightXValue">-0.60</span>
                    </div>
                    <div class="slider-track"><div class="slider-fill" id="lightXFill"></div></div>
                    <input type="range" id="lightX" min="-1" max="1" step="0.01" value="-0.6">
                </div>
                <div class="slider-control">
                    <div class="slider-header">
                        <span class="slider-label">Light Y</span>
                        <span class="slider-value" id="lightYValue">0.70</span>
                    </div>
                    <div class="slider-track"><div class="slider-fill" id="lightYFill"></div></div>
                    <input type="range" id="lightY" min="-1" max="1" step="0.01" value="0.7">
                </div>
                <div class="slider-control">
                    <div class="slider-header">
                        <span class="slider-label">Light Z</span>
                        <span class="slider-value" id="lightZValue">0.50</span>
                    </div>
                    <div class="slider-track"><div class="slider-fill" id="lightZFill"></div></div>
                    <input type="range" id="lightZ" min="-1" max="1" step="0.01" value="0.5">
                </div>
                <div class="slider-control">
                    <div class="slider-header">
                        <span class="slider-label">Ambient</span>
                        <span class="slider-value" id="ambientValue">0.80</span>
                    </div>
                    <div class="slider-track"><div class="slider-fill" id="ambientFill"></div></div>
                    <input type="range" id="ambient" min="0" max="2" step="0.01" value="0.8">
                </div>
                <div class="slider-control">
                    <div class="slider-header">
                        <span class="slider-label">Diffuse</span>
                        <span class="slider-value" id="diffuseValue">1.20</span>
                    </div>
                    <div class="slider-track"><div class="slider-fill" id="diffuseFill"></div></div>
                    <input type="range" id="diffuse" min="0" max="3" step="0.01" value="1.2">
                </div>
                <div class="slider-control">
                    <div class="slider-header">
                        <span class="slider-label">Shadow Softness</span>
                        <span class="slider-value" id="shadowSoftValue">8.00</span>
                    </div>
                    <div class="slider-track"><div class="slider-fill" id="shadowSoftFill"></div></div>
                    <input type="range" id="shadowSoft" min="1" max="20" step="0.5" value="8">
                </div>
            </div>

            <!-- Colors -->
            <div class="section">
                <div class="section-title">Colors</div>
                <div class="color-control">
                    <div class="color-picker-wrapper">
                        <input type="color" id="objectColor" value="#808080">
                    </div>
                    <span class="color-label">Object Color</span>
                    <span class="color-hex" id="objectColorHex">#808080</span>
                </div>
                <div class="color-control">
                    <div class="color-picker-wrapper">
                        <input type="color" id="lightColor" value="#f2cc99">
                    </div>
                    <span class="color-label">Light Color</span>
                    <span class="color-hex" id="lightColorHex">#f2cc99</span>
                </div>
                <div class="color-control">
                    <div class="color-picker-wrapper">
                        <input type="color" id="ambientColor" value="#80b3cc">
                    </div>
                    <span class="color-label">Ambient Color</span>
                    <span class="color-hex" id="ambientColorHex">#80b3cc</span>
                </div>
                <div class="color-control">
                    <div class="color-picker-wrapper">
                        <input type="color" id="bgColor" value="#0a0b0d">
                    </div>
                    <span class="color-label">Background</span>
                    <span class="color-hex" id="bgColorHex">#0a0b0d</span>
                </div>
            </div>

            <!-- Actions -->
            <div class="section">
                <div class="section-title">Actions</div>
                <div class="btn-group">
                    <button class="btn btn-secondary" id="resetBtn">Reset</button>
                    <button class="btn btn-primary" id="exportBtn">Export</button>
                </div>
                <div class="btn-group">
                    <button class="btn btn-secondary" id="screenshotBtn" style="width: 100%;">Screenshot</button>
                </div>
                <div class="info-text">
                    <kbd>SPACE</kbd> Pause &nbsp; <kbd>R</kbd> Reset &nbsp; <kbd>S</kbd> Screenshot
                </div>
            </div>
        </div>
    </div>

    <!-- Export Modal -->
    <div class="modal" id="exportModal">
        <div class="modal-content">
            <div class="modal-header">
                <span class="modal-title">Export to Shadertoy</span>
                <button class="modal-close" id="modalClose">&times;</button>
            </div>
            <div class="modal-body">
                <div class="code-block" id="exportCode"></div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary copy-btn" id="copyBtn">Copy to Clipboard</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // SHADER LAB PRO+ - Icosahedron Explorer
        // ============================================

        const canvas = document.getElementById('shaderCanvas');
        const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

        if (!gl) {
            alert('WebGL not supported!');
        }

        // Vertex shader - simple fullscreen quad
        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        // ============================================
        // FRAGMENT SHADERS
        // ============================================

        const shaders = {
            // Shader 0: Icosahedron Spikes (Original)
            icosahedron: `
                precision highp float;

                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 iMouse;

                // Custom uniforms
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                #define PI 3.14159265359
                #define saturate(x) clamp(x, 0., 1.)

                float t;

                float vmax(vec3 v) {
                    return max(max(v.x, v.y), v.z);
                }

                float fBox(vec3 p, vec3 b) {
                    vec3 d = abs(p) - b;
                    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));
                }

                float fLineSegment(vec3 p, vec3 a, vec3 b) {
                    vec3 ab = b - a;
                    float t = saturate(dot(p - a, ab) / dot(ab, ab));
                    return length((ab*t + a) - p);
                }

                float fCapsule(vec3 p, vec3 a, vec3 b, float r) {
                    return fLineSegment(p, a, b) - r;
                }

                float fPlane(vec3 p, vec3 n, float distanceFromOrigin) {
                    return dot(p, n) + distanceFromOrigin;
                }

                float fPlane(vec3 p, vec3 a, vec3 b, vec3 c, vec3 inside, float distanceFromOrigin) {
                    vec3 n = normalize(cross(c - b, a - b));
                    float d = -dot(a, n);
                    if (dot(n, inside) + d > 0.) {
                        n = -n;
                        d = -d;
                    }
                    return fPlane(p, n, d + distanceFromOrigin);
                }

                float fOpIntersectionRound(float a, float b, float r) {
                    float m = max(a, b);
                    if ((-a < r) && (-b < r)) {
                        return max(m, -(r - sqrt((r+a)*(r+a) + (r+b)*(r+b))));
                    } else {
                        return m;
                    }
                }

                float fCone(vec3 p, float radius, float height) {
                    vec2 q = vec2(length(p.xz), p.y);
                    vec2 tip = q - vec2(0, height);
                    vec2 mantleDir = normalize(vec2(height, radius));
                    float mantle = dot(tip, mantleDir);
                    float d = max(mantle, -q.y);
                    float projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));
                    if ((q.y > height) && (projected < 0.)) {
                        d = max(d, length(tip));
                    }
                    if ((q.x > radius) && (projected > length(vec2(height, radius)))) {
                        d = max(d, length(q - vec2(radius, 0)));
                    }
                    return d;
                }

                void pR(inout vec2 p, float a) {
                    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);
                }

                float pReflect(inout vec3 p, vec3 planeNormal, float offset) {
                    float t = dot(p, planeNormal)+offset;
                    if (t < 0.) {
                        p = p - (2.*t)*planeNormal;
                    }
                    return sign(t);
                }

                float fOpUnionRound(float a, float b, float r) {
                    float m = min(a, b);
                    if ((a < r) && (b < r)) {
                        return min(m, r - sqrt((r-a)*(r-a) + (r-b)*(r-b)));
                    } else {
                        return m;
                    }
                }

                vec3 bToC(vec3 A, vec3 B, vec3 C, vec3 barycentric) {
                    return barycentric.x * A + barycentric.y * B + barycentric.z * C;
                }

                int Type = 5;
                vec3 nc, pab, pbc, pca;
                vec3 icoF0, icoF1a;
                vec3 icoA0, icoB0, icoC0;
                vec3 icoA1, icoB1, icoC1;
                vec3 fold1, fold2, fold3;

                void initIcosahedron() {
                    float cospin = cos(PI/float(Type)), scospin = sqrt(0.75-cospin*cospin);
                    nc = vec3(-0.5, -cospin, scospin);
                    pab = vec3(0., 0., 1.);
                    pbc = vec3(scospin, 0., 0.5);
                    pca = vec3(0., scospin, cospin);
                    pbc = normalize(pbc);
                    pca = normalize(pca);

                    vec3 A = pbc;
                    vec3 C = reflect(A, normalize(cross(pab, pca)));
                    vec3 B = reflect(C, normalize(cross(pbc, pca)));

                    icoF0 = pca;
                    icoA0 = A;
                    icoC0 = B;
                    icoB0 = C;

                    vec3 p1 = bToC(A, B, C, vec3(.5, .0, .5));
                    vec3 p2 = bToC(A, B, C, vec3(.5, .5, .0));
                    fold1 = normalize(cross(p1, p2));

                    vec3 A2 = reflect(A, fold1);
                    vec3 B2 = p1;
                    vec3 C2 = p2;

                    icoF1a = pca;
                    icoA1 = A2;
                    icoB1 = normalize(B2);
                    icoC1 = normalize(C2);

                    p1 = bToC(A2, B2, C2, vec3(.5, .0, .5));
                    p2 = bToC(A2, B2, C2, vec3(.5, .5, .0));
                    fold2 = normalize(cross(p1, p2));

                    p1 = bToC(A2, B2, C2, vec3(.0, .5, .5));
                    fold3 = normalize(cross(p2, p1));
                }

                float pModIcosahedron(inout vec3 p, int subdivisions) {
                    p = abs(p);
                    pReflect(p, nc, 0.);
                    p.xy = abs(p.xy);
                    pReflect(p, nc, 0.);
                    p.xy = abs(p.xy);
                    pReflect(p, nc, 0.);

                    float i = 0.;

                    if (subdivisions > 0) {
                        i += pReflect(p, fold1, 0.) / 2. + .5;
                        if (subdivisions > 1) {
                            pReflect(p, fold2, 0.);
                            pReflect(p, fold3, 0.);
                        }
                    }
                    return i;
                }

                mat3 rotationMatrix(vec3 axis, float angle) {
                    axis = normalize(axis);
                    float s = sin(angle);
                    float c = cos(angle);
                    float oc = 1.0 - c;
                    return mat3(
                        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,
                        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,
                        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c
                    );
                }

                vec3 pRoll(inout vec3 p) {
                    pR(p.yx, PI/3.);
                    pR(p.yz, PI/-5.);
                    mat3 m = rotationMatrix(normalize(icoF1a), t * ((PI*2.)/3.));
                    p *= m;
                    return p;
                }

                float fCone2(vec3 p, float radius, float height, vec3 direction) {
                    p = reflect(p, normalize(mix(vec3(0,1,0), -direction, .5)));
                    return fCone(p, radius, height);
                }

                float fHolePart(vec3 p, vec3 a, vec3 b, vec3 c, vec3 d, float round, float thick) {
                    vec3 center = (a + b + c + d) / 4.;
                    float f0 = fPlane(p, a, b, c, center, thick);
                    float f1 = fPlane(p, a, c, d, center, thick);
                    float f = f0;
                    f = fOpIntersectionRound(f, f1, round);
                    return f;
                }

                float fHole(vec3 p, vec3 a, vec3 b, vec3 c) {
                    float w = 1.;
                    float h = 1.;
                    float round = .08;
                    float thick = .02;

                    vec3 AB = mix(a, b, 0.5);
                    vec3 AAB = mix(a, b, w);
                    vec3 ABB = mix(a, b, 1. - w);
                    vec3 n = normalize(cross(a, b));
                    vec3 cn = dot(c, n) * n;
                    vec3 AF = c - cn * (1. - h);
                    vec3 AF2 = reflect(AF, n);

                    float part1 = fHolePart(p, vec3(0), AF2, AAB, AF, round, thick);
                    float part2 = fHolePart(p, vec3(0), AF2, ABB, AF, round, thick);
                    float hole = fOpIntersectionRound(part1, part2, round);
                    return hole;
                }

                float holes(vec3 p, float i) {
                    float d = 1000.;
                    if (i > 0.) {
                        return min(d, fHole(p, icoC1, icoB1, icoF1a));
                    }
                    d = min(d, fHole(p, icoC1, icoB1, icoF1a));
                    d = min(d, fHole(p, icoA1, icoB1, icoF1a));
                    return d;
                }

                float spikes(vec3 p) {
                    float d = 1000.;
                    d = min(d, fCone2(p, uSpikeWidth, uSpikeLength, icoF1a));
                    d = min(d, fCone2(p, uSpikeWidth, uSpikeLength * 1.3, icoA1));
                    d = min(d, fCone2(p, uSpikeWidth, uSpikeLength * 1.4, icoB1));
                    return d;
                }

                float shell(vec3 p, float i) {
                    float thick = uShellThickness;
                    float round = .015;

                    float d = length(p) - uSphereRadius;
                    d = fOpUnionRound(d, spikes(p), uSmoothing);
                    d = max(d, -(length(p) - (uSphereRadius - thick)));
                    float h = holes(p, i);
                    h = max(h, (length(p) - (uSphereRadius + 0.1)));
                    d = fOpIntersectionRound(d, -h, round);
                    return d;
                }

                float model(vec3 p) {
                    pRoll(p);
                    float d = 1000.;
                    float i = 0.;
                    i = pModIcosahedron(p, 1);
                    d = min(d, shell(p, i));
                    return d;
                }

                const float MAX_TRACE_DISTANCE = 10.0;
                const float INTERSECTION_PRECISION = 0.001;
                const int NUM_OF_TRACE_STEPS = 100;

                vec2 map(vec3 p) {
                    return vec2(model(p), 1.);
                }

                float softshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax) {
                    float res = 1.0;
                    float t = mint;
                    for(int i = 0; i < 16; i++) {
                        float h = map(ro + rd*t).x;
                        res = min(res, uShadowSoft * h / t);
                        t += clamp(h, 0.02, 0.10);
                        if(h < 0.001 || t > tmax) break;
                    }
                    return clamp(res, 0.0, 1.0);
                }

                float calcAO(in vec3 pos, in vec3 nor) {
                    float occ = 0.0;
                    float sca = 1.0;
                    for(int i = 0; i < 5; i++) {
                        float hr = 0.01 + 0.12 * float(i) / 4.0;
                        vec3 aopos = nor * hr + pos;
                        float dd = map(aopos).x;
                        occ += -(dd - hr) * sca;
                        sca *= 0.95;
                    }
                    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);
                }

                const float GAMMA = 2.2;

                vec3 gamma(vec3 color, float g) {
                    return pow(color, vec3(g));
                }

                vec3 linearToScreen(vec3 linearRGB) {
                    return gamma(linearRGB, 1.0 / GAMMA);
                }

                vec3 doLighting(vec3 col, vec3 pos, vec3 nor, vec3 ref, vec3 rd) {
                    float occ = calcAO(pos, nor);
                    vec3 lig = normalize(uLightDir);
                    float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);
                    float dif = clamp(dot(nor, lig), 0.0, 1.0);
                    float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);
                    float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);

                    dif *= softshadow(pos, lig, 0.02, 2.5);

                    vec3 lin = vec3(0.0);
                    lin += uDiffuse * dif * uLightColor;
                    lin += uAmbient * amb * uAmbientColor * occ;
                    lin += 0.30 * bac * vec3(0.25) * occ;
                    lin += 0.20 * fre * vec3(1.00) * occ;
                    col = col * lin;

                    return col;
                }

                vec2 calcIntersection(in vec3 ro, in vec3 rd) {
                    float h = INTERSECTION_PRECISION * 2.0;
                    float t = 0.0;
                    float res = -1.0;
                    float id = -1.;

                    for(int i = 0; i < NUM_OF_TRACE_STEPS; i++) {
                        if(h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE) break;
                        vec2 m = map(ro + rd * t);
                        h = m.x;
                        t += h;
                        id = m.y;
                    }

                    if(t < MAX_TRACE_DISTANCE) res = t;
                    if(t > MAX_TRACE_DISTANCE) id = -1.0;

                    return vec2(res, id);
                }

                mat3 calcLookAtMatrix(in vec3 ro, in vec3 ta, in float roll) {
                    vec3 ww = normalize(ta - ro);
                    vec3 uu = normalize(cross(ww, vec3(sin(roll), cos(roll), 0.0)));
                    vec3 vv = normalize(cross(uu, ww));
                    return mat3(uu, vv, ww);
                }

                void doCamera(out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse) {
                    vec3 orient = normalize(vec3(.1, uCamHeight, 0.));
                    float zoom = uZoom;
                    zoom -= mouse.y * 3.5;
                    camPos = zoom * orient;
                    camTar = vec3(0);
                }

                vec3 calcNormal(in vec3 pos) {
                    vec3 eps = vec3(0.001, 0.0, 0.0);
                    vec3 nor = vec3(
                        map(pos + eps.xyy).x - map(pos - eps.xyy).x,
                        map(pos + eps.yxy).x - map(pos - eps.yxy).x,
                        map(pos + eps.yyx).x - map(pos - eps.yyx).x
                    );
                    return normalize(nor);
                }

                vec3 render(vec2 res, vec3 ro, vec3 rd) {
                    vec3 color = uBgColor;

                    if(res.y > -.5) {
                        vec3 pos = ro + rd * res.x;
                        vec3 norm = calcNormal(pos);
                        vec3 ref = reflect(rd, norm);

                        color = uObjectColor;
                        color = doLighting(color, pos, norm, ref, rd);
                    }

                    return color;
                }

                void main() {
                    t = (iTime * uSpeed + uTimeOffset);
                    t = mod(t / 4., 1.);

                    initIcosahedron();

                    vec2 p = (-iResolution.xy + 2.0 * gl_FragCoord.xy) / iResolution.y;
                    vec2 m = iMouse.xy / iResolution.xy;

                    vec3 ro = vec3(0., 0., 2.);
                    vec3 ta = vec3(0., 0., 0.);

                    doCamera(ro, ta, iTime, m);

                    mat3 camMat = calcLookAtMatrix(ro, ta, 0.0);
                    vec3 rd = normalize(camMat * vec3(p.xy, uFov));

                    vec2 res = calcIntersection(ro, rd);

                    vec3 color = render(res, ro, rd);
                    color = linearToScreen(color);

                    gl_FragColor = vec4(color, 1.0);
                }
            `,

            // Shader 1: Plasma Sphere
            plasmaSphere: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                #define PI 3.14159265359

                float noise(vec3 p) {
                    return fract(sin(dot(p, vec3(12.9898, 78.233, 45.543))) * 43758.5453);
                }

                float sdSphere(vec3 p, float r) {
                    return length(p) - r;
                }

                float plasma(vec3 p, float t) {
                    float v = 0.0;
                    v += sin(p.x * 10.0 + t);
                    v += sin(p.y * 10.0 + t * 0.5);
                    v += sin(p.z * 10.0 + t * 0.7);
                    v += sin((p.x + p.y + p.z) * 5.0 + t * 2.0);
                    return v * 0.1;
                }

                float map(vec3 p, float t) {
                    float d = sdSphere(p, uSphereRadius);
                    d += plasma(p, t) * uSpikeLength;
                    return d;
                }

                vec3 calcNormal(vec3 p, float t) {
                    vec2 e = vec2(0.001, 0.0);
                    return normalize(vec3(
                        map(p + e.xyy, t) - map(p - e.xyy, t),
                        map(p + e.yxy, t) - map(p - e.yxy, t),
                        map(p + e.yyx, t) - map(p - e.yyx, t)
                    ));
                }

                void main() {
                    float t = iTime * uSpeed + uTimeOffset;
                    vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;
                    vec2 m = iMouse.xy / iResolution.xy;

                    vec3 ro = vec3(0.0, 0.0, uZoom - m.y * 2.0);
                    vec3 rd = normalize(vec3(uv, -uFov));

                    float d = 0.0;
                    vec3 p;

                    for(int i = 0; i < 64; i++) {
                        p = ro + rd * d;
                        float h = map(p, t);
                        if(h < 0.001 || d > 10.0) break;
                        d += h;
                    }

                    vec3 col = uBgColor;

                    if(d < 10.0) {
                        vec3 n = calcNormal(p, t);
                        vec3 l = normalize(uLightDir);
                        float diff = max(dot(n, l), 0.0);
                        float spec = pow(max(dot(reflect(-l, n), -rd), 0.0), 32.0);

                        vec3 plasmaCol = 0.5 + 0.5 * cos(t + p * 2.0 + vec3(0, 2, 4));
                        col = mix(uObjectColor, plasmaCol, 0.5);
                        col = col * (uAmbient * uAmbientColor + uDiffuse * diff * uLightColor);
                        col += spec * 0.5;
                    }

                    col = pow(col, vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 2: Fractal Orb
            fractalOrb: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                #define PI 3.14159265359

                vec3 fold(vec3 p) {
                    p = abs(p);
                    if(p.x < p.y) p.xy = p.yx;
                    if(p.x < p.z) p.xz = p.zx;
                    if(p.y < p.z) p.yz = p.zy;
                    return p;
                }

                float fractal(vec3 p, float t) {
                    float s = uSphereRadius;
                    for(int i = 0; i < 8; i++) {
                        p = fold(p);
                        p = p * 2.0 - vec3(1.0 + uSpikeLength);
                        p.xy *= mat2(cos(t * 0.1), sin(t * 0.1), -sin(t * 0.1), cos(t * 0.1));
                        s *= 2.0;
                    }
                    return length(p) / s - uShellThickness;
                }

                vec3 calcNormal(vec3 p, float t) {
                    vec2 e = vec2(0.001, 0.0);
                    return normalize(vec3(
                        fractal(p + e.xyy, t) - fractal(p - e.xyy, t),
                        fractal(p + e.yxy, t) - fractal(p - e.yxy, t),
                        fractal(p + e.yyx, t) - fractal(p - e.yyx, t)
                    ));
                }

                void main() {
                    float t = iTime * uSpeed + uTimeOffset;
                    vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;
                    vec2 m = iMouse.xy / iResolution.xy;

                    vec3 ro = vec3(0.0, uCamHeight - 1.0, uZoom - m.y * 2.0);
                    vec3 rd = normalize(vec3(uv, -uFov));

                    float d = 0.0;
                    vec3 p;

                    for(int i = 0; i < 100; i++) {
                        p = ro + rd * d;
                        float h = fractal(p, t);
                        if(abs(h) < 0.0005 || d > 15.0) break;
                        d += h * 0.5;
                    }

                    vec3 col = uBgColor;

                    if(d < 15.0) {
                        vec3 n = calcNormal(p, t);
                        vec3 l = normalize(uLightDir);
                        float diff = max(dot(n, l), 0.0);
                        float ao = 1.0 - d * 0.05;

                        col = uObjectColor;
                        col = col * (uAmbient * uAmbientColor + uDiffuse * diff * uLightColor) * ao;
                    }

                    col = pow(col, vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 3: Crystal Matrix
            crystalMatrix: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                #define PI 3.14159265359

                float sdBox(vec3 p, vec3 b) {
                    vec3 d = abs(p) - b;
                    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);
                }

                float sdOctahedron(vec3 p, float s) {
                    p = abs(p);
                    return (p.x + p.y + p.z - s) * 0.57735027;
                }

                vec3 repeat(vec3 p, vec3 c) {
                    return mod(p + 0.5 * c, c) - 0.5 * c;
                }

                float map(vec3 p, float t) {
                    vec3 q = repeat(p, vec3(2.0 * uSphereRadius));

                    float oct = sdOctahedron(q, uSpikeLength * 0.5);
                    float box = sdBox(q, vec3(uSpikeWidth));

                    float d = max(oct, -box);

                    q.xy *= mat2(cos(t), sin(t), -sin(t), cos(t));
                    float oct2 = sdOctahedron(q, uSpikeLength * 0.3);
                    d = min(d, oct2);

                    return d * 0.5;
                }

                vec3 calcNormal(vec3 p, float t) {
                    vec2 e = vec2(0.001, 0.0);
                    return normalize(vec3(
                        map(p + e.xyy, t) - map(p - e.xyy, t),
                        map(p + e.yxy, t) - map(p - e.yxy, t),
                        map(p + e.yyx, t) - map(p - e.yyx, t)
                    ));
                }

                void main() {
                    float t = iTime * uSpeed + uTimeOffset;
                    vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;
                    vec2 m = iMouse.xy / iResolution.xy;

                    vec3 ro = vec3(sin(t * 0.2) * 3.0, uCamHeight, cos(t * 0.2) * 3.0 + uZoom);
                    vec3 ta = vec3(0.0);
                    vec3 ww = normalize(ta - ro);
                    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));
                    vec3 vv = cross(uu, ww);
                    vec3 rd = normalize(uv.x * uu + uv.y * vv + uFov * ww);

                    float d = 0.0;
                    vec3 p;

                    for(int i = 0; i < 80; i++) {
                        p = ro + rd * d;
                        float h = map(p, t);
                        if(h < 0.001 || d > 20.0) break;
                        d += h;
                    }

                    vec3 col = uBgColor;

                    if(d < 20.0) {
                        vec3 n = calcNormal(p, t);
                        vec3 l = normalize(uLightDir);
                        float diff = max(dot(n, l), 0.0);
                        float spec = pow(max(dot(reflect(-l, n), -rd), 0.0), 64.0);
                        float fres = pow(1.0 - abs(dot(n, rd)), 3.0);

                        col = uObjectColor;
                        col = col * (uAmbient * uAmbientColor + uDiffuse * diff * uLightColor);
                        col += spec * uLightColor * 0.5;
                        col += fres * uAmbientColor * 0.3;
                    }

                    col = pow(col, vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 4: Neon Wireframe - EPIC UPGRADE (Optimized)
            neonWireframe: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                #define PI 3.14159265359
                #define TAU 6.28318530718

                mat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }

                float sdTorus(vec3 p, vec2 t) {
                    vec2 q = vec2(length(p.xz) - t.x, p.y);
                    return length(q) - t.y;
                }

                float smin(float a, float b, float k) {
                    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
                    return mix(b, a, h) - k * h * (1.0 - h);
                }

                float map(vec3 p, float t) {
                    vec3 q = p;
                    q.xy *= rot(t * 0.3);
                    q.yz *= rot(t * 0.23);

                    float r = uSphereRadius;
                    float w = uSpikeWidth * 0.8;

                    // 3 interlocking tori (unrolled for performance)
                    float d = sdTorus(q, vec2(r, w));
                    vec3 rp = q; rp.xz *= rot(TAU / 3.0); rp.yz *= rot(0.7);
                    d = smin(d, sdTorus(rp, vec2(r, w)), 0.1);
                    rp = q; rp.xz *= rot(TAU * 2.0 / 3.0); rp.yz *= rot(1.4);
                    d = smin(d, sdTorus(rp, vec2(r, w)), 0.1);

                    // Gyroid pattern
                    vec3 gp = q * (3.0 + uShellThickness);
                    float gyro = abs(dot(sin(gp), cos(gp.zxy))) * 0.3 - 0.03;
                    float shell = max(gyro, length(q) - r * 1.2);
                    d = smin(d, shell, 0.15);

                    // Pulsing core
                    float core = length(q) - r * 0.3 * (1.0 + sin(t * 2.0) * 0.2);
                    d = smin(d, core, 0.2);

                    return d;
                }

                vec3 calcNormal(vec3 p, float t) {
                    vec2 e = vec2(0.002, 0.0);
                    return normalize(vec3(
                        map(p + e.xyy, t) - map(p - e.xyy, t),
                        map(p + e.yxy, t) - map(p - e.yxy, t),
                        map(p + e.yyx, t) - map(p - e.yyx, t)
                    ));
                }

                void main() {
                    float t = iTime * uSpeed + uTimeOffset;
                    vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;
                    vec2 m = iMouse.xy / iResolution.xy;
                    if(iMouse.z < 0.5) m = vec2(0.5);

                    vec3 ro = vec3(0.0, uCamHeight, uZoom);
                    ro.xz *= rot(m.x * TAU - PI);
                    ro.yz *= rot((m.y - 0.5) * PI * 0.5);
                    vec3 ta = vec3(0.0);
                    vec3 ww = normalize(ta - ro);
                    vec3 uu = normalize(cross(ww, vec3(0, 1, 0)));
                    vec3 vv = cross(uu, ww);
                    vec3 rd = normalize(uv.x * uu + uv.y * vv + uFov * ww);

                    float d = 0.0;
                    vec3 p;
                    float glowAccum = 0.0;

                    for(int i = 0; i < 64; i++) {
                        p = ro + rd * d;
                        float h = map(p, t);
                        glowAccum += uSmoothing / (abs(h) + uSmoothing) * 0.02;
                        if(h < 0.001 || d > 15.0) break;
                        d += h;
                    }

                    vec3 col = uBgColor;
                    col += uObjectColor * glowAccum * 0.4;
                    col += uLightColor * glowAccum * 0.2;

                    if(d < 15.0) {
                        vec3 n = calcNormal(p, t);
                        vec3 l = normalize(uLightDir);
                        float diff = max(dot(n, l), 0.0);
                        float spec = pow(max(dot(reflect(-l, n), -rd), 0.0), 32.0);
                        float fres = pow(1.0 - abs(dot(n, rd)), 3.0);

                        col = uObjectColor * (uAmbient * uAmbientColor + diff * uDiffuse * uLightColor);
                        col += spec * uLightColor * 2.0;
                        col += fres * uLightColor * 1.5;
                        col *= 0.9 + 0.1 * sin(p.y * 30.0 + t * 3.0);
                    }

                    col = pow(col, vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 5: Cyberpunk City - OPTIMIZED
            cyberpunkCity: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                #define PI 3.14159265359

                float hash21(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }
                vec3 hash23(vec2 p) { return fract(sin(vec3(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)),dot(p,vec2(419.2,371.9))))*43758.5453); }

                float sdBox(vec3 p, vec3 b) {
                    vec3 d = abs(p) - b;
                    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);
                }

                vec2 map(vec3 p, float t) {
                    float d = p.y + 1.0;
                    float matId = 0.0;

                    vec3 q = p;
                    vec2 cellSize = vec2(3.0 + uSpikeWidth * 3.0);
                    vec2 id = floor(q.xz / cellSize);
                    q.xz = mod(q.xz + cellSize * 0.5, cellSize) - cellSize * 0.5;

                    float rnd = hash21(id);
                    float rnd2 = hash21(id + 100.0);

                    // Building height with variation
                    float h = (rnd * 0.8 + 0.2) * uSpikeLength * 4.0 + 0.5;
                    h *= smoothstep(15.0, 0.0, length(id * cellSize));

                    // Main building (simplified)
                    vec3 buildingSize = vec3(0.9 + rnd2 * 0.3, h, 0.9 + rnd * 0.3);
                    float building = sdBox(q - vec3(0, h - 1.0, 0), buildingSize);

                    if(building < d) {
                        d = building;
                        matId = 1.0;
                    }

                    // Neon vehicles (unrolled, 2 only)
                    vec3 car1 = vec3(sin(t * 0.3) * 8.0, 2.5 + sin(t * 0.5) * 0.5, mod(t * 3.0, 60.0) - 30.0);
                    float v1 = length(p - car1) - 0.2;
                    if(v1 < d) { d = v1; matId = 2.0; }

                    vec3 car2 = vec3(sin(t * 0.3 + 2.0) * 8.0, 4.0 + sin(t * 0.5 + 1.0) * 0.5, mod(t * 4.5 + 20.0, 60.0) - 30.0);
                    float v2 = length(p - car2) - 0.2;
                    if(v2 < d) { d = v2; matId = 3.0; }

                    // Neon sign
                    float signY = 3.0 + sin(t * 0.5 + id.x) * 0.3;
                    vec3 signPos = q - vec3(0.9, signY, 0);
                    float sign = sdBox(signPos, vec3(0.02, 0.3, 0.5));
                    if(sign < d && rnd > 0.4) { d = sign; matId = 5.0; }

                    return vec2(d, matId);
                }

                vec3 calcNormal(vec3 p, float t) {
                    vec2 e = vec2(0.002, 0.0);
                    return normalize(vec3(
                        map(p + e.xyy, t).x - map(p - e.xyy, t).x,
                        map(p + e.yxy, t).x - map(p - e.yxy, t).x,
                        map(p + e.yyx, t).x - map(p - e.yyx, t).x
                    ));
                }

                float windowGlow(vec3 p, float t) {
                    float ws = 0.25;
                    vec2 wuv = vec2(mod(p.x + 0.15, 0.3), mod(p.y + ws * 0.5, ws));
                    float lit = step(0.7, hash21(floor(p.xz * 3.0) + floor(p.y / ws)));
                    lit *= step(0.1, wuv.x) * step(wuv.x, 0.2);
                    lit *= step(0.05, wuv.y) * step(wuv.y, 0.2);
                    return lit * (0.8 + 0.2 * sin(t * 10.0 + hash21(floor(p.xz * 3.0)) * 100.0));
                }

                vec3 neonColor(float id, float t) {
                    if(id < 3.0) return uLightColor;
                    if(id < 4.0) return vec3(1.0, 0.2, 0.5);
                    return mix(uObjectColor, uLightColor, sin(t * 2.0) * 0.5 + 0.5);
                }

                void main() {
                    float t = iTime * uSpeed + uTimeOffset;
                    vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;
                    vec2 m = iMouse.xy / iResolution.xy;
                    if(iMouse.z < 0.5) m = vec2(0.5, 0.4);

                    // Fly-through camera
                    vec3 ro = vec3(sin(t * 0.1) * 5.0, uCamHeight + 3.0 + sin(t * 0.15) * 2.0, t * 3.0);
                    vec3 ta = ro + vec3(sin(m.x * 4.0 - 2.0) * 3.0, (m.y - 0.5) * 4.0, 8.0);

                    vec3 ww = normalize(ta - ro);
                    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));
                    vec3 vv = cross(uu, ww);
                    vec3 rd = normalize(uv.x * uu + uv.y * vv + uFov * ww);

                    float d = 0.0;
                    vec3 p;
                    vec3 glowCol = vec3(0.0);

                    for(int i = 0; i < 64; i++) {
                        p = ro + rd * d;
                        vec2 res = map(p, t);
                        float h = res.x;

                        // Glow accumulation
                        if(res.y > 1.5) {
                            float glowDist = uSmoothing / (abs(h) + uSmoothing);
                            glowCol += neonColor(res.y, t) * glowDist * 0.02;
                        }

                        if(h < 0.001 || d > 50.0) break;
                        d += h * 0.9;
                    }

                    // Sky gradient
                    vec3 sky = mix(uBgColor, uBgColor * 2.0, uv.y * 0.5 + 0.5);
                    sky += uLightColor * 0.1 * exp(-abs(uv.y) * 3.0);
                    vec3 col = sky;

                    if(d < 50.0) {
                        vec2 res = map(p, t);
                        vec3 n = calcNormal(p, t);
                        float diff = max(dot(n, normalize(uLightDir)), 0.0);

                        if(res.y < 1.5) {
                            col = uObjectColor * 0.3;
                            col += uAmbientColor * uAmbient * 0.2;
                            col += uLightColor * diff * uDiffuse * 0.3;

                            // Window emission
                            float wg = windowGlow(p, t);
                            vec3 windowCol = mix(vec3(1.0, 0.9, 0.7), uLightColor, hash23(floor(p.xz * 3.0)).x);
                            col += windowCol * wg * 1.5;

                            // Edge glow
                            float edge = 1.0 - abs(dot(n, rd));
                            col += uLightColor * pow(edge, 3.0) * uShellThickness * 5.0;
                        } else {
                            col = neonColor(res.y, t) * 3.0;
                        }

                        // Fog
                        col = mix(col, sky + uLightColor * 0.05, 1.0 - exp(-d * 0.03));
                    }

                    col += glowCol;

                    // Rain (optimized)
                    col += vec3(0.3) * step(0.995, hash21(uv * 100.0 + t * 50.0));

                    // Scanlines + vignette
                    col *= (0.95 + 0.05 * sin(gl_FragCoord.y * 1.5)) * (1.0 - length(uv) * 0.3);

                    col = pow(col, vec3(1.0/2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 6: Liquid Metal - OPTIMIZED
            liquidMetal: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                #define PI 3.14159265359
                #define TAU 6.28318530718

                mat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }

                float hash31(vec3 p) { return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453); }

                float noise(vec3 p) {
                    vec3 i = floor(p), f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    return mix(mix(mix(hash31(i), hash31(i + vec3(1,0,0)), f.x),
                                   mix(hash31(i + vec3(0,1,0)), hash31(i + vec3(1,1,0)), f.x), f.y),
                               mix(mix(hash31(i + vec3(0,0,1)), hash31(i + vec3(1,0,1)), f.x),
                                   mix(hash31(i + vec3(0,1,1)), hash31(i + vec3(1,1,1)), f.x), f.y), f.z);
                }

                float smin(float a, float b, float k) {
                    float h = max(k - abs(a - b), 0.0) / k;
                    return min(a, b) - h * h * k * 0.25;
                }

                float map(vec3 p, float t) {
                    vec3 q = p;
                    q.xy *= rot(t * 0.2);
                    q.yz *= rot(t * 0.15);

                    // Base blob
                    float d = length(q) - uSphereRadius;

                    // Inline turbulence (2 octaves instead of 5)
                    float turb = noise(q * 2.0 + t * 0.3) * 0.5 + noise(q * 4.0 + t * 0.3) * 0.25;
                    d += turb * uSpikeLength * 0.4;

                    // Traveling waves
                    float wave = sin(q.x * 8.0 + t * 3.0) * sin(q.y * 8.0 - t * 2.0) * sin(q.z * 8.0 + t);
                    d += wave * 0.08 * uSmoothing * 3.0;

                    // Unrolled tendrils (2 instead of 4)
                    vec3 tp1 = q; tp1.xz *= rot(t * 0.3);
                    float t1 = length(tp1.xz) - 0.15 * uSpikeWidth * 5.0;
                    t1 = max(t1, -(tp1.y + uSphereRadius + sin(t * 2.0) * 0.5 * uSpikeLength));
                    t1 = max(t1, tp1.y - uSphereRadius * 0.5);
                    d = smin(d, t1, 0.3);

                    vec3 tp2 = q; tp2.xz *= rot(t * 0.3 + PI);
                    float t2 = length(tp2.xz) - 0.15 * uSpikeWidth * 5.0;
                    t2 = max(t2, -(tp2.y + uSphereRadius + sin(t * 2.0 + 2.0) * 0.5 * uSpikeLength));
                    t2 = max(t2, tp2.y - uSphereRadius * 0.5);
                    d = smin(d, t2, 0.3);

                    // Rippling surface
                    d += sin(length(q.xz) * 15.0 - t * 5.0) * 0.02 * uShellThickness * 3.0;

                    return d * 0.8;
                }

                vec3 calcNormal(vec3 p, float t) {
                    vec2 e = vec2(0.001, 0.0);
                    return normalize(vec3(
                        map(p + e.xyy, t) - map(p - e.xyy, t),
                        map(p + e.yxy, t) - map(p - e.yxy, t),
                        map(p + e.yyx, t) - map(p - e.yyx, t)
                    ));
                }

                vec3 envMap(vec3 rd) {
                    vec3 col = uBgColor * 0.5;
                    col += uAmbientColor * smoothstep(-0.5, 0.5, rd.y) * 0.5;

                    // Studio lights (simplified)
                    col += uLightColor * pow(max(dot(rd, normalize(vec3(1, 1, 0.5))), 0.0), 32.0) * 2.0;
                    col += uObjectColor * pow(max(dot(rd, normalize(vec3(-1, 0.5, -0.5))), 0.0), 16.0);
                    col += uAmbientColor * pow(max(dot(rd, vec3(0, -1, 0)), 0.0), 8.0) * 0.5;

                    return col;
                }

                void main() {
                    float t = iTime * uSpeed + uTimeOffset;
                    vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;
                    vec2 m = iMouse.xy / iResolution.xy;
                    if(iMouse.z < 0.5) m = vec2(0.5, 0.5);

                    vec3 ro = vec3(0.0, uCamHeight * 0.5, uZoom);
                    ro.xz *= rot((m.x - 0.5) * TAU);
                    ro.yz *= rot((m.y - 0.5) * PI * 0.5);

                    vec3 ta = vec3(0.0);
                    vec3 ww = normalize(ta - ro);
                    vec3 uu = normalize(cross(ww, vec3(0, 1, 0)));
                    vec3 vv = cross(uu, ww);
                    vec3 rd = normalize(uv.x * uu + uv.y * vv + uFov * ww);

                    float d = 0.0;
                    vec3 p;

                    for(int i = 0; i < 64; i++) {
                        p = ro + rd * d;
                        float h = map(p, t);
                        if(h < 0.001 || d > 15.0) break;
                        d += h;
                    }

                    vec3 col = envMap(rd);

                    if(d < 15.0) {
                        vec3 n = calcNormal(p, t);
                        vec3 l = normalize(uLightDir);
                        vec3 ref = reflect(rd, n);

                        // Fresnel
                        float fres = pow(1.0 - abs(dot(n, -rd)), 4.0);
                        fres = mix(0.2, 1.0, fres);

                        // Environment reflection
                        vec3 envCol = envMap(ref);

                        // Specular highlights
                        float spec1 = pow(max(dot(ref, l), 0.0), 64.0);
                        float spec2 = pow(max(dot(ref, normalize(vec3(-1, 1, 0))), 0.0), 32.0);

                        // Base metal color
                        vec3 metalCol = uObjectColor * 0.3;

                        // Anisotropic streaks
                        metalCol += uLightColor * abs(sin(atan(n.z, n.x) * 20.0 + t)) * 0.1;

                        // Combine
                        col = metalCol * (1.0 - fres);
                        col += envCol * fres;
                        col += uLightColor * spec1 * 3.0;
                        col += uObjectColor * spec2 * 1.5;

                        // Edge glow
                        col += uLightColor * pow(1.0 - abs(dot(n, -rd)), 2.0) * 0.3;
                    }

                    // Tone mapping + gamma
                    col = col / (col + 1.0);
                    col = pow(col, vec3(1.0/2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 7: Quantum Flux - OPTIMIZED
            quantumFlux: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                #define PI 3.14159265359
                #define TAU 6.28318530718

                mat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }

                vec3 palette(float t) {
                    return 0.5 + 0.5 * cos(TAU * (vec3(0.0, 0.33, 0.67) + t));
                }

                float map(vec3 p, float t) {
                    vec3 q = p;
                    q.xy *= rot(t * 0.1);
                    q.yz *= rot(t * 0.07);

                    float sphere = length(q) - uSphereRadius;

                    // Inline quantum field (2 octaves instead of 5)
                    vec3 q1 = q; q1.xy *= rot(t * 0.3); q1.yz *= rot(t * 0.2);
                    vec3 q2 = q * 2.0; q2.xy *= rot(t * 0.6); q2.yz *= rot(t * 0.4);
                    float field = (sin(q1.x * 3.0) * sin(q1.y * 3.0) * sin(q1.z * 3.0) +
                                   sin(q2.x * 3.0) * sin(q2.y * 3.0) * sin(q2.z * 3.0) * 0.5) * 0.15;

                    float d = sphere + field * uSpikeLength;

                    // Probability clouds
                    d += sin(q.x * 5.0 + t) * sin(q.y * 5.0 - t * 0.7) * sin(q.z * 5.0 + t * 0.5) * uSmoothing * 0.5;

                    // Orbiting particles (unrolled to 2)
                    float angle1 = t * 0.5;
                    vec3 orbit1 = vec3(cos(angle1), sin(angle1 * 0.7), sin(angle1)) * uSphereRadius * 1.5;
                    d = min(d, length(q - orbit1) - 0.1 * uSpikeWidth * 5.0);

                    float angle2 = t * 0.8 + TAU / 3.0;
                    vec3 orbit2 = vec3(cos(angle2), sin(angle2 * 0.7), sin(angle2)) * uSphereRadius * 1.8;
                    d = min(d, length(q - orbit2) - 0.1 * uSpikeWidth * 5.0);

                    return d;
                }

                vec3 calcNormal(vec3 p, float t) {
                    vec2 e = vec2(0.002, 0.0);
                    return normalize(vec3(
                        map(p + e.xyy, t) - map(p - e.xyy, t),
                        map(p + e.yxy, t) - map(p - e.yxy, t),
                        map(p + e.yyx, t) - map(p - e.yyx, t)
                    ));
                }

                void main() {
                    float t = iTime * uSpeed + uTimeOffset;
                    vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;
                    vec2 m = iMouse.xy / iResolution.xy;
                    if(iMouse.z < 0.5) m = vec2(0.5);

                    vec3 ro = vec3(0.0, uCamHeight, uZoom);
                    ro.xz *= rot(m.x * TAU);
                    ro.yz *= rot((m.y - 0.5) * PI * 0.5);

                    vec3 ta = vec3(0.0);
                    vec3 ww = normalize(ta - ro);
                    vec3 uu = normalize(cross(ww, vec3(0, 1, 0)));
                    vec3 vv = cross(uu, ww);
                    vec3 rd = normalize(uv.x * uu + uv.y * vv + uFov * ww);

                    float d = 0.0;
                    vec3 p;
                    float glow = 0.0;
                    vec3 glowCol = vec3(0.0);

                    for(int i = 0; i < 64; i++) {
                        p = ro + rd * d;
                        float h = map(p, t);
                        float g = uSmoothing / (abs(h) + uSmoothing * 0.5);
                        glow += g * 0.012;
                        glowCol += palette(length(p) * 0.5 - t * 0.3) * g * 0.018;
                        if(h < 0.001 || d > 20.0) break;
                        d += h * 0.9;
                    }

                    vec3 col = uBgColor;
                    col += glowCol;
                    col += uObjectColor * glow * 0.3;

                    if(d < 20.0) {
                        vec3 n = calcNormal(p, t);
                        vec3 l = normalize(uLightDir);
                        float diff = max(dot(n, l), 0.0);
                        float spec = pow(max(dot(reflect(-l, n), -rd), 0.0), 32.0);
                        float fres = pow(1.0 - abs(dot(n, rd)), 3.0);

                        vec3 qCol = palette(dot(p, vec3(1.0)) * 0.2 + t * 0.2);
                        col = qCol * (uAmbient + diff * uDiffuse);
                        col += uLightColor * spec * 2.0;
                        col += uLightColor * fres;

                        // Quantum interference
                        col *= 0.8 + (sin(length(p) * 20.0 - t * 5.0) * 0.5 + 0.5) * 0.4;
                    }

                    col = pow(col, vec3(1.0/2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 8: Void Tendrils - OPTIMIZED
            voidTendrils: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                #define PI 3.14159265359
                #define TAU 6.28318530718

                mat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }
                float hash(float n) { return fract(sin(n) * 43758.5453); }

                float tendril(vec3 p, float t, float angle, float id) {
                    p.xz *= rot(angle);
                    p.xy *= rot(sin(t * 0.5 + id) * 0.5);
                    p.xz *= rot((atan(p.z, p.x) + p.y * 2.0 + t) * 0.2);
                    float r = abs(length(p.xz) - 0.1 - sin(p.y * 3.0 + t * 2.0 + id * 2.0) * 0.05 * uSpikeWidth * 5.0) - 0.02;
                    return r / smoothstep(uSphereRadius * 3.0 * uSpikeLength, 0.0, abs(p.y)) - 0.001;
                }

                float map(vec3 p, float t) {
                    vec3 q = p;
                    q.xy *= rot(t * 0.1);
                    q.yz *= rot(t * 0.07);

                    // Event horizon
                    float d = abs(length(q) - uSphereRadius) - uShellThickness * 0.5;

                    // Unrolled tendrils (4 instead of 8)
                    d = min(d, tendril(q, t, 0.0, 0.0));
                    d = min(d, tendril(q, t, TAU * 0.25, 2.0));
                    d = min(d, tendril(q, t, TAU * 0.5, 4.0));
                    d = min(d, tendril(q, t, TAU * 0.75, 6.0));

                    // Accretion disk
                    float disk = max(abs(q.y) - 0.02, length(q.xz) - uSphereRadius * 1.5);
                    disk = max(disk, -(length(q.xz) - uSphereRadius * 2.5));
                    d = min(d, disk);

                    return d;
                }

                vec3 calcNormal(vec3 p, float t) {
                    vec2 e = vec2(0.002, 0.0);
                    return normalize(vec3(
                        map(p + e.xyy, t) - map(p - e.xyy, t),
                        map(p + e.yxy, t) - map(p - e.yxy, t),
                        map(p + e.yyx, t) - map(p - e.yyx, t)
                    ));
                }

                void main() {
                    float t = iTime * uSpeed + uTimeOffset;
                    vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;
                    vec2 m = iMouse.xy / iResolution.xy;
                    if(iMouse.z < 0.5) m = vec2(0.3, 0.4);

                    vec3 ro = vec3(0.0, uCamHeight, uZoom + 2.0);
                    ro.xz *= rot(m.x * TAU);
                    ro.yz *= rot((m.y - 0.5) * PI * 0.5);

                    vec3 ta = vec3(0.0);
                    vec3 ww = normalize(ta - ro);
                    vec3 uu = normalize(cross(ww, vec3(0, 1, 0)));
                    vec3 vv = cross(uu, ww);
                    vec3 rd = normalize(uv.x * uu + uv.y * vv + uFov * ww);

                    float d = 0.0;
                    vec3 p;
                    float glow = 0.0;

                    for(int i = 0; i < 64; i++) {
                        p = ro + rd * d;
                        float h = map(p, t);
                        glow += uSmoothing / (abs(h) + uSmoothing) * 0.012;
                        if(h < 0.001 || d > 25.0) break;
                        d += h * 0.85;
                    }

                    // Deep void background with simple stars
                    vec3 col = uBgColor * 0.3;
                    float stars = hash(dot(rd, vec3(127.1, 311.7, 74.7)) * 500.0);
                    col += vec3(step(0.98, stars) * 0.5);

                    col += uObjectColor * glow * 0.4;
                    col += uLightColor * glow * 0.2;

                    if(d < 25.0) {
                        vec3 n = calcNormal(p, t);
                        float diff = max(dot(n, normalize(uLightDir)), 0.0);
                        float fres = pow(1.0 - abs(dot(n, rd)), 2.0);

                        float energy = sin(length(p) * 10.0 - t * 3.0) * 0.5 + 0.5;
                        vec3 voidCol = mix(uObjectColor, uLightColor, energy);

                        col = voidCol * (uAmbient * 0.5 + diff * uDiffuse);
                        col += uLightColor * fres * 1.5;
                        col *= 1.0 + (1.0 - smoothstep(0.0, uSphereRadius, length(p))) * 2.0;
                    }

                    col *= 1.0 - smoothstep(uSphereRadius * 0.5, 0.0, length(p)) * 0.8;
                    col = pow(col, vec3(1.0/2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 9: Prismatic Storm - OPTIMIZED
            prismaticStorm: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                #define PI 3.14159265359
                #define TAU 6.28318530718

                mat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }

                vec3 hsv2rgb(vec3 c) {
                    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
                    return c.z * mix(vec3(1.0), rgb, c.y);
                }

                float sdOctahedron(vec3 p, float s) {
                    p = abs(p);
                    return (p.x + p.y + p.z - s) * 0.57735027;
                }

                float map(vec3 p, float t) {
                    vec3 q = p;
                    float c1 = cos(t * 0.2), s1 = sin(t * 0.2);
                    float c2 = cos(t * 0.15), s2 = sin(t * 0.15);
                    q = vec3(q.x * c1 + q.z * s1, q.y * c2 - (q.x * (-s1) + q.z * c1) * s2, q.y * s2 + (q.x * (-s1) + q.z * c1) * c2);

                    // Central crystals (unrolled 3)
                    vec3 cp1 = q; cp1.xz *= rot(t * 0.3); cp1.y += sin(t) * 0.2 * uSpikeLength;
                    float d = sdOctahedron(cp1, uSphereRadius * 0.5);

                    vec3 cp2 = q; cp2.xz *= rot(t * 0.3 + TAU / 3.0); cp2.y += sin(t + 1.0) * 0.2 * uSpikeLength;
                    d = min(d, sdOctahedron(cp2, uSphereRadius * 0.6));

                    vec3 cp3 = q; cp3.xz *= rot(t * 0.3 + TAU * 2.0 / 3.0); cp3.y += sin(t + 2.0) * 0.2 * uSpikeLength;
                    d = min(d, sdOctahedron(cp3, uSphereRadius * 0.7));

                    // Orbiting prisms (unrolled 4)
                    float orbitR = uSphereRadius * 2.0;
                    float prismSize = 0.2 * uSpikeWidth * 5.0;

                    float a1 = t * 0.5;
                    vec3 pp1 = q - vec3(cos(a1) * orbitR, sin(t * 0.7) * 0.5, sin(a1) * orbitR);
                    pp1.xz *= rot(t * 2.0); pp1.yz *= rot(t * 1.5);
                    vec3 qp1 = abs(pp1);
                    d = min(d, max(qp1.z - prismSize * 2.0, max(qp1.x * 0.866025 + pp1.y * 0.5, -pp1.y) - prismSize * 0.5));

                    float a2 = t * 0.5 + TAU * 0.25;
                    vec3 pp2 = q - vec3(cos(a2) * orbitR, sin(t * 0.7 + 2.0) * 0.5, sin(a2) * orbitR);
                    pp2.xz *= rot(t * 2.0 + 2.0); pp2.yz *= rot(t * 1.5);
                    vec3 qp2 = abs(pp2);
                    d = min(d, max(qp2.z - prismSize * 2.0, max(qp2.x * 0.866025 + pp2.y * 0.5, -pp2.y) - prismSize * 0.5));

                    float a3 = t * 0.5 + TAU * 0.5;
                    vec3 pp3 = q - vec3(cos(a3) * orbitR, sin(t * 0.7 + 4.0) * 0.5, sin(a3) * orbitR);
                    pp3.xz *= rot(t * 2.0 + 4.0); pp3.yz *= rot(t * 1.5);
                    vec3 qp3 = abs(pp3);
                    d = min(d, max(qp3.z - prismSize * 2.0, max(qp3.x * 0.866025 + pp3.y * 0.5, -pp3.y) - prismSize * 0.5));

                    float a4 = t * 0.5 + TAU * 0.75;
                    vec3 pp4 = q - vec3(cos(a4) * orbitR, sin(t * 0.7 + 6.0) * 0.5, sin(a4) * orbitR);
                    pp4.xz *= rot(t * 2.0 + 6.0); pp4.yz *= rot(t * 1.5);
                    vec3 qp4 = abs(pp4);
                    d = min(d, max(qp4.z - prismSize * 2.0, max(qp4.x * 0.866025 + pp4.y * 0.5, -pp4.y) - prismSize * 0.5));

                    // Energy shell
                    float shell = abs(length(q) - uSphereRadius * 1.5) - uShellThickness * 0.3;
                    shell += sin(q.x * 10.0 + t) * sin(q.y * 10.0 - t) * sin(q.z * 10.0) * uSmoothing * 0.5;
                    d = min(d, shell);

                    return d;
                }

                vec3 calcNormal(vec3 p, float t) {
                    vec2 e = vec2(0.002, 0.0);
                    return normalize(vec3(
                        map(p + e.xyy, t) - map(p - e.xyy, t),
                        map(p + e.yxy, t) - map(p - e.yxy, t),
                        map(p + e.yyx, t) - map(p - e.yyx, t)
                    ));
                }

                void main() {
                    float t = iTime * uSpeed + uTimeOffset;
                    vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;
                    vec2 m = iMouse.xy / iResolution.xy;
                    if(iMouse.z < 0.5) m = vec2(0.5);

                    vec3 ro = vec3(0.0, uCamHeight, uZoom + 1.0);
                    ro.xz *= rot(m.x * TAU);
                    ro.yz *= rot((m.y - 0.5) * PI * 0.5);

                    vec3 ta = vec3(0.0);
                    vec3 ww = normalize(ta - ro);
                    vec3 uu = normalize(cross(ww, vec3(0, 1, 0)));
                    vec3 vv = cross(uu, ww);
                    vec3 rd = normalize(uv.x * uu + uv.y * vv + uFov * ww);

                    float d = 0.0;
                    vec3 p;
                    float glow = 0.0;
                    vec3 glowCol = vec3(0.0);

                    for(int i = 0; i < 64; i++) {
                        p = ro + rd * d;
                        float h = map(p, t);

                        float g = uSmoothing / (abs(h) + uSmoothing * 0.3);
                        glowCol += hsv2rgb(vec3(fract(length(p) * 0.3 - t * 0.2), 0.8, 1.0)) * g * 0.02;
                        glow += g * 0.012;

                        if(h < 0.001 || d > 20.0) break;
                        d += h * 0.9;
                    }

                    vec3 col = uBgColor + glowCol;

                    if(d < 20.0) {
                        vec3 n = calcNormal(p, t);
                        vec3 l = normalize(uLightDir);
                        float diff = max(dot(n, l), 0.0);
                        float spec = pow(max(dot(reflect(-l, n), -rd), 0.0), 64.0);
                        float fres = pow(1.0 - abs(dot(n, rd)), 3.0);

                        float hue = fract(dot(p, n) * 0.5 + t * 0.1);
                        vec3 crystalCol = hsv2rgb(vec3(hue, 0.6, 1.0));

                        col = crystalCol * (uAmbient + diff * uDiffuse);
                        col += uLightColor * spec * 3.0;
                        col += hsv2rgb(vec3(fract(hue + 0.5), 0.8, 1.0)) * fres;
                        col += uObjectColor * glow * 0.3;
                    }

                    col += glowCol * 0.5;
                    col = pow(col, vec3(1.0/2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 10: Biomech Entity - OPTIMIZED
            biomechEntity: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                #define PI 3.14159265359
                #define TAU 6.28318530718

                mat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }

                float smin(float a, float b, float k) {
                    float h = max(k - abs(a - b), 0.0) / k;
                    return min(a, b) - h * h * k * 0.25;
                }

                float hash(float n) { return fract(sin(n) * 43758.5453); }

                float noise(vec3 p) {
                    vec3 i = floor(p), f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    float n = i.x + i.y * 57.0 + i.z * 113.0;
                    return mix(mix(mix(hash(n), hash(n + 1.0), f.x),
                                   mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y),
                               mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),
                                   mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);
                }

                float sdCapsule(vec3 p, vec3 a, vec3 b, float r) {
                    vec3 pa = p - a, ba = b - a;
                    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0)) - r;
                }

                float limb(vec3 q, float t, float angle, float idx) {
                    vec3 lp = q;
                    lp.xz *= rot(angle);
                    float phase = t * 0.5 + idx;
                    vec3 j1 = vec3(uSphereRadius, 0, 0);
                    vec3 j2 = j1 + vec3(uSpikeLength * 0.8, sin(phase) * 0.3, cos(phase * 0.7) * 0.2);
                    float seg1 = sdCapsule(lp, vec3(0), j1, uSpikeWidth * 1.5);
                    float seg2 = sdCapsule(lp, j1, j2, uSpikeWidth);
                    float jnt = length(lp - j1) - uSpikeWidth * 2.0;
                    return min(min(seg1, seg2), jnt);
                }

                float map(vec3 p, float t) {
                    vec3 q = p;
                    q.xy *= rot(t * 0.15);
                    q.yz *= rot(t * 0.1);

                    // Body with inline noise (2 octaves)
                    float body = length(q) - uSphereRadius;
                    vec3 nq = q * 3.0 + t * 0.5;
                    float turb = (noise(nq) * 0.5 + noise(nq * 2.0) * 0.25) * 0.3 * uSmoothing * 3.0;
                    body += turb;

                    float d = body;

                    // Limbs (unrolled 3)
                    d = smin(d, limb(q, t, 0.0, 0.0), 0.15);
                    d = smin(d, limb(q, t, TAU / 3.0, 2.0), 0.15);
                    d = smin(d, limb(q, t, TAU * 2.0 / 3.0, 4.0), 0.15);

                    // Surface veins
                    float veins = abs(sin(q.x * 15.0 + t * 2.0) * sin(q.y * 15.0 - t * 1.4)) - 0.1;
                    float veinMask = smoothstep(uSphereRadius + 0.1, uSphereRadius - 0.1, length(q));
                    d = min(d, max(veins * 0.1, body - 0.05) * veinMask + body * (1.0 - veinMask));

                    // Plates
                    float plates = max(abs(mod(atan(q.z, q.x) * 3.0 / PI + 0.5, 1.0) - 0.5) - uShellThickness, body - 0.02) * 0.5;
                    d = min(d, plates);

                    return d;
                }

                vec3 calcNormal(vec3 p, float t) {
                    vec2 e = vec2(0.002, 0.0);
                    return normalize(vec3(
                        map(p + e.xyy, t) - map(p - e.xyy, t),
                        map(p + e.yxy, t) - map(p - e.yxy, t),
                        map(p + e.yyx, t) - map(p - e.yyx, t)
                    ));
                }

                void main() {
                    float t = iTime * uSpeed + uTimeOffset;
                    vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;
                    vec2 m = iMouse.xy / iResolution.xy;
                    if(iMouse.z < 0.5) m = vec2(0.5);

                    vec3 ro = vec3(0.0, uCamHeight, uZoom + 1.5);
                    ro.xz *= rot(m.x * TAU);
                    ro.yz *= rot((m.y - 0.5) * PI * 0.5);

                    vec3 ta = vec3(0.0);
                    vec3 ww = normalize(ta - ro);
                    vec3 uu = normalize(cross(ww, vec3(0, 1, 0)));
                    vec3 vv = cross(uu, ww);
                    vec3 rd = normalize(uv.x * uu + uv.y * vv + uFov * ww);

                    float d = 0.0;
                    vec3 p;
                    float glow = 0.0;

                    for(int i = 0; i < 64; i++) {
                        p = ro + rd * d;
                        float h = map(p, t);
                        glow += uSmoothing / (abs(h) + uSmoothing) * 0.01;
                        if(h < 0.001 || d > 20.0) break;
                        d += h * 0.9;
                    }

                    vec3 col = uBgColor;

                    if(d < 20.0) {
                        vec3 n = calcNormal(p, t);
                        vec3 l = normalize(uLightDir);
                        float diff = max(dot(n, l), 0.0);
                        float spec = pow(max(dot(reflect(-l, n), -rd), 0.0), 32.0);
                        float fres = pow(1.0 - abs(dot(n, rd)), 2.0);

                        // Simple organic/mech blend
                        float blend = noise(p * 5.0);
                        vec3 baseCol = mix(uObjectColor, uLightColor * 0.5, smoothstep(0.4, 0.6, blend));

                        col = baseCol * (uAmbient + diff * uDiffuse);
                        col += uLightColor * spec * 1.5;
                        col += uLightColor * fres * 0.5;
                        col += uLightColor * glow * (sin(t * 3.0) * 0.5 + 0.5) * 0.5;
                    }

                    col += uObjectColor * glow * 0.2;
                    col = pow(col, vec3(1.0/2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 11: Fractal Cosmos - Based on coyote's shader
            fractalCosmos: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                mat3 getRotYMat(float a) {
                    return mat3(cos(a), 0., sin(a), 0., 1., 0., -sin(a), 0., cos(a));
                }

                mat3 getRotXMat(float a) {
                    return mat3(1., 0., 0., 0., cos(a), -sin(a), 0., sin(a), cos(a));
                }

                void main() {
                    float t = (iTime * uSpeed + uTimeOffset) * 0.2;
                    vec2 s = iResolution.xy;
                    float c, d, m;
                    vec3 p = vec3((2.0 * gl_FragCoord.xy - s) / s.x, uFov);
                    vec3 r = p - p;
                    vec3 q = r;

                    p *= getRotYMat(-t);
                    p *= getRotXMat(t * 0.3);
                    q.zx += uZoom + vec2(sin(t), cos(t)) * uSpikeLength * 3.0;

                    for (float i = 1.0; i > 0.0; i -= 0.01) {
                        c = 0.0;
                        d = 0.0;
                        m = 1.0;
                        for (int j = 0; j < 3; j++) {
                            r = max(r *= r *= r *= r = mod(q * m + 1.0, 2.0) - 1.0, r.yzx);
                            d = max(d, (uShellThickness - length(r) * 0.6) / m) * 0.8;
                            m *= 1.1 + uSpikeWidth;
                        }
                        q += p * d;
                        c = i;
                        if (d < 1e-5) break;
                    }

                    float k = dot(r, r + uSmoothing);
                    vec3 baseCol = vec3(1.0, k, k / c) - 0.8;
                    vec3 col = mix(uBgColor, uObjectColor * baseCol * uDiffuse + uLightColor * k * uAmbient, c);
                    col = pow(max(col, 0.0), vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 12: Plasma Vortex - Classic plasma effect
            plasmaVortex: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                void main() {
                    float t = iTime * uSpeed + uTimeOffset;
                    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;
                    uv *= uZoom;

                    float v = 0.0;
                    vec2 c = uv;

                    // Classic plasma waves
                    v += sin((c.x + t) * uSpikeLength * 3.0);
                    v += sin((c.y + t) * uSpikeLength * 3.0);
                    v += sin((c.x + c.y + t) * uSpikeLength * 2.0);

                    c += uSphereRadius * vec2(sin(t / 3.0), cos(t / 2.0));
                    v += sin(length(c) * uSpikeLength * 5.0 + t);

                    c += uSphereRadius * vec2(sin(t / 2.0), cos(t / 1.5));
                    v += sin(length(c) * uSpikeLength * 4.0 - t * 1.5);

                    // Swirl effect
                    float angle = atan(uv.y, uv.x);
                    float radius = length(uv);
                    v += sin(angle * uShellThickness * 30.0 + radius * 10.0 - t * 2.0) * 0.5;

                    v = v / 3.5;

                    vec3 col = vec3(
                        sin(v * 3.14159 + t) * 0.5 + 0.5,
                        sin(v * 3.14159 + t + 2.094) * 0.5 + 0.5,
                        sin(v * 3.14159 + t + 4.188) * 0.5 + 0.5
                    );

                    col = mix(col, uObjectColor, 0.3) * uDiffuse;
                    col += uLightColor * uAmbient * 0.2;
                    col = mix(uBgColor, col, 0.9);

                    col = pow(max(col, 0.0), vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 13: Neon Boxes - Rotating animated boxes
            neonBoxes: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                float gTime = 0.0;

                mat2 rot(float a) {
                    float c = cos(a), s = sin(a);
                    return mat2(c, s, -s, c);
                }

                float sdBox(vec3 p, vec3 b) {
                    vec3 q = abs(p) - b;
                    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
                }

                float box(vec3 pos, float scale) {
                    pos *= scale;
                    float base = sdBox(pos, vec3(0.4, 0.4, 0.1 * uShellThickness * 10.0)) / 1.5;
                    pos.xy *= 5.0;
                    pos.y -= 3.5;
                    pos.xy *= rot(0.75);
                    return -base;
                }

                float box_set(vec3 pos) {
                    vec3 pos_origin = pos;
                    float boxScale = 2.0 - abs(sin(gTime * 0.4)) * uSpikeLength;

                    pos = pos_origin;
                    pos.y += sin(gTime * 0.4) * 2.5;
                    pos.xy *= rot(0.8);
                    float box1 = box(pos, boxScale);

                    pos = pos_origin;
                    pos.y -= sin(gTime * 0.4) * 2.5;
                    pos.xy *= rot(0.8);
                    float box2 = box(pos, boxScale);

                    pos = pos_origin;
                    pos.x += sin(gTime * 0.4) * 2.5;
                    pos.xy *= rot(0.8);
                    float box3 = box(pos, boxScale);

                    pos = pos_origin;
                    pos.x -= sin(gTime * 0.4) * 2.5;
                    pos.xy *= rot(0.8);
                    float box4 = box(pos, boxScale);

                    pos = pos_origin;
                    pos.xy *= rot(0.8);
                    float box5 = box(pos, 0.5) * 6.0;

                    pos = pos_origin;
                    float box6 = box(pos, 0.5) * 6.0;

                    return max(max(max(max(max(box1, box2), box3), box4), box5), box6);
                }

                float map(vec3 pos) {
                    return box_set(pos);
                }

                void main() {
                    float t = iTime * uSpeed + uTimeOffset;
                    vec2 p = (gl_FragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);
                    vec3 ro = vec3(0.0, -0.2 + uCamHeight, t * uZoom);
                    vec3 ray = normalize(vec3(p, uFov));
                    ray.xy = ray.xy * rot(sin(t * 0.03) * 5.0);
                    ray.yz = ray.yz * rot(sin(t * 0.05) * 0.2);

                    float d = 0.1;
                    vec3 col = vec3(0.0);
                    float ac = 0.0;

                    for (int i = 0; i < 99; i++) {
                        vec3 pos = ro + ray * d;
                        pos = mod(pos - 2.0, 4.0) - 2.0;
                        gTime = t - float(i) * 0.01;

                        float dist = map(pos);
                        dist = max(abs(dist), 0.01);
                        ac += exp(-dist * uShadowSoft);
                        d += dist * 0.55;
                    }

                    col = vec3(ac * 0.02 * uDiffuse);
                    col += uObjectColor * 0.5 + uLightColor * 0.2 * abs(sin(t));
                    col = mix(uBgColor, col, 1.0 - d * (0.02 + 0.02 * sin(t)));
                    col = pow(max(col, 0.0), vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 14: Warp Tunnel - Simple tunnel flythrough
            warpTunnel: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                void main() {
                    float t = iTime * uSpeed + uTimeOffset;
                    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;

                    // Polar coordinates for tunnel
                    float angle = atan(uv.y, uv.x);
                    float radius = length(uv);

                    // Prevent division by zero at center
                    radius = max(radius, 0.01);

                    // Tunnel depth effect
                    float depth = uZoom / radius;

                    // Scrolling texture coordinates
                    float tx = angle / 3.14159;
                    float ty = depth - t * 2.0;

                    // Create tunnel pattern
                    float pattern = 0.0;

                    // Ring pattern
                    float rings = sin(ty * uSpikeLength * 5.0) * 0.5 + 0.5;

                    // Spiral pattern
                    float spiral = sin(angle * uShellThickness * 10.0 + ty * 3.0) * 0.5 + 0.5;

                    // Grid pattern
                    float gridX = abs(sin(tx * 10.0 * uSphereRadius));
                    float gridY = abs(sin(ty * 2.0));
                    float grid = max(gridX, gridY);

                    pattern = mix(rings, spiral, 0.5) * grid;

                    // Depth fog
                    float fog = 1.0 - smoothstep(0.0, uZoom * 2.0, depth);

                    // Color based on depth and pattern
                    vec3 col = uObjectColor * pattern;
                    col += uLightColor * rings * 0.3;

                    // Add glow at edges
                    float edgeGlow = smoothstep(0.5, 0.0, radius) * uAmbient;
                    col += uLightColor * edgeGlow * 0.5;

                    // Apply fog
                    col = mix(col * uDiffuse, uBgColor, fog);

                    // Vignette
                    col *= 1.0 - radius * 0.5;

                    col = pow(max(col, 0.0), vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 15: Hyperdrive - Original hyperspace warp effect
            hyperdrive: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                float hash(vec2 p) {
                    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                }

                void main() {
                    float t = iTime * uSpeed + uTimeOffset;
                    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;

                    vec3 col = uBgColor;
                    float stars = 0.0;
                    float trails = 0.0;

                    for (float layer = 0.0; layer < 4.0; layer++) {
                        float depth = 1.0 + layer * 0.5;
                        float speed = uZoom * depth;

                        for (float i = 0.0; i < 100.0; i++) {
                            vec2 starPos = vec2(
                                hash(vec2(i, layer)) - 0.5,
                                hash(vec2(i + 100.0, layer)) - 0.5
                            ) * 2.0;

                            float z = mod(hash(vec2(i + 200.0, layer)) * 10.0 - t * speed, 10.0);
                            float size = uSpikeWidth * 0.1 / (z + 0.1);

                            vec2 projected = starPos / (z * 0.1 + 0.01);
                            float dist = length(uv - projected);

                            // Star point
                            stars += smoothstep(size, 0.0, dist) * (1.0 - z / 10.0);

                            // Motion trail
                            vec2 trailDir = normalize(projected);
                            float trailLen = uSpikeLength * size * 20.0 * (1.0 - z / 10.0);
                            float trailDist = length(uv - projected + trailDir * trailLen * 0.5);
                            float trail = smoothstep(size * 3.0, 0.0, abs(dot(uv - projected, vec2(-trailDir.y, trailDir.x))));
                            trail *= smoothstep(trailLen, 0.0, length(uv - projected));
                            trails += trail * (1.0 - z / 10.0) * 0.3;
                        }
                    }

                    // Central vortex glow
                    float vortex = 1.0 / (length(uv) * uShadowSoft + 0.5);
                    vortex *= 0.5 + 0.5 * sin(t * 3.0 + length(uv) * 20.0);

                    col += uLightColor * stars * uDiffuse;
                    col += uObjectColor * trails;
                    col += uAmbientColor * vortex * uAmbient * 0.3;

                    // Color shift based on position
                    col += vec3(0.1, 0.0, 0.2) * (1.0 - length(uv)) * uSmoothing;

                    col = pow(max(col, 0.0), vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 16: Neural Storm - Electric energy field
            neuralStorm: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                void main() {
                    float t = iTime * uSpeed + uTimeOffset;
                    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;
                    uv *= uZoom;

                    vec3 col = uBgColor;

                    // Multiple energy layers
                    float energy = 0.0;

                    for (float i = 0.0; i < 8.0; i++) {
                        float phase = i * 0.785; // PI/4
                        float speed = 1.0 + i * 0.2;

                        // Rotating wave pattern
                        vec2 ruv = uv;
                        float ca = cos(t * 0.2 + phase);
                        float sa = sin(t * 0.2 + phase);
                        ruv = vec2(ruv.x * ca - ruv.y * sa, ruv.x * sa + ruv.y * ca);

                        // Wave function
                        float wave = sin(ruv.x * uSpikeLength * 10.0 + t * speed);
                        wave *= sin(ruv.y * uSpikeLength * 10.0 - t * speed * 0.7);

                        // Distance from center affects intensity
                        float dist = length(uv);
                        float intensity = exp(-dist * uShellThickness * 3.0);

                        energy += wave * intensity / (i + 1.0);
                    }

                    // Pulsing center glow
                    float centerDist = length(uv);
                    float centerGlow = uSphereRadius * 0.1 / (centerDist + 0.1);
                    centerGlow *= 0.5 + 0.5 * sin(t * 3.0);

                    // Radial beams
                    float angle = atan(uv.y, uv.x);
                    float beams = abs(sin(angle * uSpikeWidth * 10.0 + t));
                    beams *= exp(-centerDist * 2.0);

                    // Color composition
                    energy = energy * 0.5 + 0.5;

                    col += uObjectColor * energy * uDiffuse;
                    col += uLightColor * centerGlow * uAmbient;
                    col += uAmbientColor * beams * 0.5;

                    // Electric crackle effect
                    float crackle = sin(uv.x * 50.0 + t * 10.0) * sin(uv.y * 50.0 - t * 8.0);
                    crackle = smoothstep(0.9, 1.0, abs(crackle));
                    col += uLightColor * crackle * 0.3 * exp(-centerDist * 3.0);

                    col = pow(max(col, 0.0), vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 17: Cosmic Singularity - Black hole with accretion disk
            cosmicSingularity: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                #define PI 3.14159265359

                float hash(float n) { return fract(sin(n) * 43758.5453); }

                float noise(vec2 p) {
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    float n = i.x + i.y * 57.0;
                    return mix(mix(hash(n), hash(n + 1.0), f.x),
                               mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y);
                }

                float fbm(vec2 p) {
                    float f = 0.0;
                    f += 0.5000 * noise(p); p *= 2.02;
                    f += 0.2500 * noise(p); p *= 2.03;
                    f += 0.1250 * noise(p); p *= 2.01;
                    f += 0.0625 * noise(p);
                    return f / 0.9375;
                }

                void main() {
                    float t = iTime * uSpeed + uTimeOffset;
                    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;

                    vec3 col = uBgColor;

                    float dist = length(uv);
                    float angle = atan(uv.y, uv.x);

                    // Gravitational lensing distortion
                    float lensStrength = uSphereRadius * 0.15 / (dist + 0.1);
                    vec2 lensedUV = uv + normalize(uv) * lensStrength * uSpikeLength;

                    // Event horizon (black hole center)
                    float eventHorizon = uShellThickness * 0.08;
                    float holeEdge = smoothstep(eventHorizon, eventHorizon + 0.02, dist);

                    // Accretion disk
                    float diskAngle = angle + t * 0.5;
                    float diskDist = length(lensedUV);

                    // Disk shape - tilted ellipse
                    vec2 diskUV = lensedUV;
                    diskUV.y *= 2.5 + sin(t * 0.3) * uCamHeight;
                    float diskR = length(diskUV);

                    // Disk bands
                    float diskInner = uShellThickness * 0.12;
                    float diskOuter = uShellThickness * 0.5 + uSpikeWidth * 0.3;
                    float diskMask = smoothstep(diskInner, diskInner + 0.05, diskR) *
                                    smoothstep(diskOuter + 0.05, diskOuter, diskR);

                    // Swirling matter in disk
                    float swirl = fbm(vec2(diskAngle * 3.0 + t, diskR * 10.0 - t * 2.0));
                    float hotSpots = pow(swirl, 2.0) * 2.0;

                    // Disk color - hot plasma gradient
                    vec3 diskColor = mix(uObjectColor, uLightColor, hotSpots);
                    diskColor += vec3(1.0, 0.5, 0.1) * pow(swirl, 3.0) * uDiffuse;

                    // Relativistic jets
                    float jetAngle = abs(uv.y) / (abs(uv.x) + 0.01);
                    float jet = smoothstep(5.0, 15.0, jetAngle) * smoothstep(0.5, 0.1, dist);
                    jet *= (0.5 + 0.5 * sin(dist * 30.0 - t * 5.0)) * uSpikeLength;

                    // Photon sphere glow
                    float photonSphere = exp(-abs(dist - eventHorizon * 1.5) * uShadowSoft * 2.0);

                    // Star field background with lensing
                    vec2 starUV = lensedUV * uZoom * 3.0;
                    float stars = 0.0;
                    for (float i = 0.0; i < 3.0; i++) {
                        vec2 starPos = floor(starUV * (10.0 + i * 5.0));
                        float starRand = hash(starPos.x + starPos.y * 100.0 + i);
                        if (starRand > 0.97) {
                            vec2 starCenter = (starPos + 0.5) / (10.0 + i * 5.0);
                            float starDist = length(starUV / (10.0 + i * 5.0) - starCenter);
                            stars += 0.01 / (starDist + 0.005) * starRand;
                        }
                    }

                    // Compose final image
                    col += uAmbientColor * stars * holeEdge;
                    col += diskColor * diskMask * holeEdge * uDiffuse;
                    col += uLightColor * photonSphere * uAmbient * 0.5;
                    col += vec3(0.5, 0.7, 1.0) * jet * holeEdge;

                    // Darken center for black hole
                    col *= holeEdge;

                    // Add edge glow
                    float edgeGlow = exp(-abs(dist - eventHorizon) * 50.0) * (1.0 - holeEdge + 0.1);
                    col += uLightColor * edgeGlow * 2.0;

                    col = pow(max(col, 0.0), vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 18: Dimensional Rift - Reality-tearing portal effect
            dimensionalRift: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec4 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                #define PI 3.14159265359

                float hash(vec2 p) {
                    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                }

                float voronoi(vec2 p) {
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    float minDist = 1.0;
                    for (int y = -1; y <= 1; y++) {
                        for (int x = -1; x <= 1; x++) {
                            vec2 neighbor = vec2(float(x), float(y));
                            vec2 point = hash(i + neighbor) * vec2(0.5) + 0.25;
                            float d = length(neighbor + point - f);
                            minDist = min(minDist, d);
                        }
                    }
                    return minDist;
                }

                mat2 rot(float a) {
                    float c = cos(a), s = sin(a);
                    return mat2(c, -s, s, c);
                }

                void main() {
                    float t = iTime * uSpeed + uTimeOffset;
                    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;

                    vec3 col = uBgColor;

                    float dist = length(uv);
                    float angle = atan(uv.y, uv.x);

                    // Rift opening - pulsating tear in reality
                    float riftPulse = 0.5 + 0.3 * sin(t * 2.0) + 0.2 * sin(t * 3.7);
                    float riftWidth = uShellThickness * 0.3 * riftPulse;

                    // Jagged rift edges using layered sine waves
                    float riftShape = 0.0;
                    for (float i = 1.0; i < 6.0; i++) {
                        riftShape += sin(angle * i * 3.0 + t * i * 0.5) / i;
                    }
                    riftShape = riftShape * 0.1 * uSpikeLength;

                    float riftDist = abs(dist - uSphereRadius * 0.3 + riftShape) - riftWidth;
                    float riftMask = smoothstep(0.02, 0.0, riftDist);

                    // Reality fractures spreading from rift
                    float fractures = 0.0;
                    for (float i = 0.0; i < 5.0; i++) {
                        float fAngle = angle + i * PI * 0.4 + t * 0.2;
                        float fDist = dist - uSphereRadius * 0.3;
                        if (fDist > 0.0 && fDist < uSpikeWidth * 0.5) {
                            float crack = abs(sin(fAngle * (8.0 + i * 3.0)));
                            crack = pow(crack, 20.0);
                            fractures += crack * (1.0 - fDist / (uSpikeWidth * 0.5));
                        }
                    }

                    // Dimensional layers visible through rift
                    vec3 dimension1 = vec3(0.0);
                    vec3 dimension2 = vec3(0.0);

                    // Dimension 1: Geometric void
                    vec2 d1uv = uv * rot(t * 0.3) * uZoom * 2.0;
                    float geo = voronoi(d1uv * 5.0 + t);
                    geo = pow(geo, 0.5);
                    dimension1 = mix(uObjectColor, uLightColor, geo) * uDiffuse;

                    // Dimension 2: Energy streams
                    vec2 d2uv = uv * rot(-t * 0.2) * uZoom * 3.0;
                    float streams = 0.0;
                    for (float i = 0.0; i < 4.0; i++) {
                        float streamAngle = atan(d2uv.y, d2uv.x) + i * PI * 0.5;
                        float streamWave = sin(streamAngle * 5.0 + length(d2uv) * 10.0 - t * 3.0);
                        streams += pow(abs(streamWave), 8.0) / (length(d2uv) + 0.5);
                    }
                    dimension2 = uAmbientColor * streams * 2.0;

                    // Blend dimensions based on time
                    float dimBlend = sin(t * 0.5) * 0.5 + 0.5;
                    vec3 portalInterior = mix(dimension1, dimension2, dimBlend);

                    // Energy discharge at rift edges
                    float discharge = 0.0;
                    for (float i = 0.0; i < 8.0; i++) {
                        float boltAngle = angle + hash(vec2(i, floor(t * 2.0))) * PI * 2.0;
                        float boltDist = dist - uSphereRadius * 0.3;
                        vec2 boltDir = vec2(cos(boltAngle), sin(boltAngle));
                        float bolt = abs(dot(normalize(uv), boltDir));
                        bolt = pow(bolt, 50.0) * step(0.0, boltDist) * step(boltDist, 0.2);
                        bolt *= (0.5 + 0.5 * sin(t * 20.0 + i * 5.0));
                        discharge += bolt;
                    }

                    // Outer reality distortion
                    float distortion = sin(dist * 20.0 - t * 2.0) * sin(angle * 8.0 + t);
                    distortion *= exp(-dist * 3.0) * uSmoothing;

                    // Edge glow
                    float edgeGlow = exp(-abs(riftDist) * uShadowSoft * 3.0);

                    // Compose
                    col = uBgColor * (1.0 + distortion * 0.3);
                    col = mix(col, portalInterior, riftMask);
                    col += uLightColor * edgeGlow * uAmbient;
                    col += uLightColor * fractures * 0.5;
                    col += vec3(1.0, 0.8, 0.5) * discharge;

                    // Pulsing outer ring
                    float ring = exp(-abs(dist - uSphereRadius * 0.5 - sin(t) * 0.1) * 20.0);
                    col += uObjectColor * ring * 0.3 * (0.5 + 0.5 * sin(t * 4.0));

                    col = pow(max(col, 0.0), vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 19: Stellar Nursery - Star-forming nebula
            stellarNursery: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec2 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                float hash(vec2 p) {
                    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                }

                float noise(vec2 p) {
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    return mix(mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
                               mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);
                }

                float fbm(vec2 p) {
                    float f = 0.0;
                    float w = 0.5;
                    for (int i = 0; i < 5; i++) {
                        f += w * noise(p);
                        p *= 2.0;
                        w *= 0.5;
                    }
                    return f;
                }

                void main() {
                    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;
                    float t = iTime * uSpeed + uTimeOffset;

                    // Scale by zoom
                    uv *= uZoom;

                    // Swirling nebula base
                    float angle = atan(uv.y, uv.x);
                    float radius = length(uv);

                    // Spiral arm distortion
                    float spiral = sin(angle * uSpikeLength * 3.0 + radius * uShellThickness * 10.0 - t * 0.5);

                    // Layered nebula clouds
                    vec2 np = uv + vec2(cos(t * 0.2), sin(t * 0.3)) * 0.5;
                    float nebula1 = fbm(np * 3.0 + t * 0.1);
                    float nebula2 = fbm(np * 5.0 - t * 0.15 + 10.0);
                    float nebula3 = fbm(np * 2.0 + t * 0.05 + 20.0);

                    // Combine nebula layers
                    float nebula = nebula1 * 0.5 + nebula2 * 0.3 + nebula3 * 0.2;
                    nebula *= (1.0 + spiral * 0.3);

                    // Star formation regions (bright spots)
                    float stars = 0.0;
                    for (int i = 0; i < 8; i++) {
                        vec2 starPos = vec2(hash(vec2(float(i), 0.0)) - 0.5, hash(vec2(0.0, float(i))) - 0.5) * 2.0;
                        starPos *= uSphereRadius;
                        float d = length(uv - starPos);
                        float pulse = 0.5 + 0.5 * sin(t * (1.0 + hash(vec2(float(i), float(i)))) + float(i));
                        stars += exp(-d * uShadowSoft * 3.0) * pulse * uDiffuse * 0.3;
                    }

                    // Dust lanes
                    float dust = fbm(uv * 8.0 + t * 0.05);
                    dust = smoothstep(0.4, 0.6, dust);

                    // Color gradients
                    vec3 col1 = uObjectColor;
                    vec3 col2 = uLightColor;
                    vec3 col3 = uAmbientColor;

                    vec3 col = uBgColor;
                    col = mix(col, col3, nebula3 * uAmbient);
                    col = mix(col, col1, nebula1 * 0.8);
                    col = mix(col, col2, nebula2 * 0.6);
                    col *= (1.0 - dust * 0.5 * uSmoothing);
                    col += vec3(1.0, 0.9, 0.7) * stars;

                    // Vignette
                    col *= 1.0 - radius * 0.3;

                    col = pow(max(col, 0.0), vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 20: Cyber Grid - Infinite neon grid
            cyberGrid: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec2 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                float hash(float n) { return fract(sin(n) * 43758.5453); }

                void main() {
                    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;
                    float t = iTime * uSpeed + uTimeOffset;

                    // Perspective grid
                    float horizon = uCamHeight * 0.1;
                    float z = uZoom / (uv.y - horizon + 0.001);
                    float x = uv.x * z;

                    vec3 col = uBgColor;

                    if (uv.y < horizon + 0.5) {
                        // Moving grid
                        float gridX = abs(fract(x * uSpikeLength) - 0.5);
                        float gridZ = abs(fract(z * uShellThickness * 0.1 - t) - 0.5);

                        float lineX = smoothstep(uSpikeWidth, 0.0, gridX);
                        float lineZ = smoothstep(uSpikeWidth, 0.0, gridZ);

                        float grid = max(lineX, lineZ);

                        // Distance fade
                        float fade = exp(-z * 0.02 * uSmoothing);
                        grid *= fade;

                        // Pulse waves traveling along grid
                        float pulse1 = sin(z * 0.5 - t * 3.0) * 0.5 + 0.5;
                        float pulse2 = sin(x * 0.3 - t * 2.0) * 0.5 + 0.5;

                        // Data streams
                        float stream = 0.0;
                        for (int i = 0; i < 5; i++) {
                            float sx = floor(x * uSpikeLength + float(i) * 0.3);
                            float streamPos = fract(hash(sx) + t * (0.5 + hash(sx + 10.0)));
                            float streamZ = streamPos * 50.0;
                            float d = abs(z - streamZ);
                            stream += exp(-d * 0.5) * step(0.48, fract(x * uSpikeLength + float(i) * 0.3 + 0.25))
                                   * step(fract(x * uSpikeLength + float(i) * 0.3 + 0.25), 0.52);
                        }
                        stream *= fade;

                        col = uBgColor;
                        col += uObjectColor * grid * uAmbient;
                        col += uLightColor * grid * pulse1 * uDiffuse * 0.5;
                        col += uAmbientColor * grid * pulse2 * 0.3;
                        col += uLightColor * stream * 2.0;

                        // Horizon glow
                        float horizonGlow = exp(-abs(uv.y - horizon) * uShadowSoft * 5.0);
                        col += uLightColor * horizonGlow * 0.5;
                    }

                    // Sun/moon
                    float sunDist = length(uv - vec2(0.0, horizon + 0.3));
                    col += uLightColor * exp(-sunDist * uShadowSoft * 2.0) * uDiffuse;

                    col = pow(max(col, 0.0), vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 21: Liquid Aurora - Flowing northern lights
            liquidAurora: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec2 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                float hash(vec2 p) {
                    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                }

                float noise(vec2 p) {
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    return mix(mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
                               mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);
                }

                void main() {
                    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;
                    float t = iTime * uSpeed + uTimeOffset;

                    vec3 col = uBgColor;

                    // Multiple aurora curtains
                    for (int i = 0; i < 5; i++) {
                        float fi = float(i);
                        float offset = fi * 0.3;

                        // Wavy curtain shape
                        float wave1 = sin(uv.x * uSpikeLength * 3.0 + t * (0.5 + fi * 0.1) + offset) * 0.2;
                        float wave2 = sin(uv.x * uSpikeLength * 7.0 - t * 0.3 + fi) * 0.1;
                        float wave3 = noise(vec2(uv.x * 2.0 + t * 0.2, fi)) * 0.15;

                        float curtainY = uCamHeight * 0.2 + wave1 + wave2 + wave3 + fi * 0.15;

                        // Curtain intensity
                        float curtain = exp(-abs(uv.y - curtainY) * uShadowSoft * 5.0);

                        // Vertical rays within curtain
                        float rays = noise(vec2(uv.x * uShellThickness * 20.0, t + fi * 10.0));
                        rays = pow(rays, 2.0);

                        // Shimmer
                        float shimmer = 0.7 + 0.3 * sin(uv.x * 50.0 + t * 5.0 + fi * 3.0);

                        // Color based on layer
                        vec3 auroraColor;
                        float colorMix = fract(fi * 0.3 + t * 0.1);
                        auroraColor = mix(uObjectColor, uLightColor, colorMix);
                        auroraColor = mix(auroraColor, uAmbientColor, sin(fi + t) * 0.5 + 0.5);

                        float intensity = curtain * (0.5 + rays * 0.5) * shimmer * uDiffuse;
                        intensity *= (1.0 - fi * 0.15); // Fade back layers

                        col += auroraColor * intensity * uAmbient;
                    }

                    // Stars
                    for (int i = 0; i < 50; i++) {
                        vec2 starPos = vec2(hash(vec2(float(i), 0.0)), hash(vec2(0.0, float(i)))) * 2.0 - 1.0;
                        starPos.x *= iResolution.x / iResolution.y;
                        float d = length(uv - starPos);
                        float twinkle = 0.5 + 0.5 * sin(t * (2.0 + hash(vec2(float(i), float(i)))) + float(i));
                        col += vec3(1.0) * exp(-d * 500.0) * twinkle * uSmoothing;
                    }

                    col = pow(max(col, 0.0), vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 22: Fractal Flame - Procedural fire fractals
            fractalFlame: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec2 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                float hash(vec2 p) {
                    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                }

                float noise(vec2 p) {
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    return mix(mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
                               mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);
                }

                float fbm(vec2 p) {
                    float f = 0.0;
                    float w = 0.5;
                    for (int i = 0; i < 6; i++) {
                        f += w * noise(p);
                        p *= 2.0;
                        w *= 0.5;
                    }
                    return f;
                }

                void main() {
                    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;
                    float t = iTime * uSpeed + uTimeOffset;

                    // Scale
                    uv *= uZoom;

                    // Rising motion
                    uv.y += t * 0.5;

                    // Turbulent distortion
                    vec2 distort;
                    distort.x = fbm(uv * uSpikeLength + t * 0.3);
                    distort.y = fbm(uv * uSpikeLength + 10.0 + t * 0.4);
                    uv += (distort - 0.5) * uShellThickness;

                    // Flame shape
                    float flame = 0.0;

                    // Multiple flame layers
                    for (int i = 0; i < 4; i++) {
                        float fi = float(i);
                        vec2 flameUV = uv * (1.0 + fi * 0.5);
                        flameUV.x += sin(flameUV.y * 3.0 + t + fi) * 0.2 * uSpikeWidth;

                        float f = fbm(flameUV * 3.0 + t * (0.5 + fi * 0.2));
                        f = pow(f, 1.5 - fi * 0.2);

                        // Vertical gradient
                        float gradient = 1.0 - (gl_FragCoord.y / iResolution.y);
                        gradient = pow(gradient, 0.5 + fi * 0.3);

                        flame += f * gradient * (1.0 - fi * 0.2);
                    }

                    flame *= uDiffuse;

                    // Color gradient based on intensity
                    vec3 col = uBgColor;

                    // Core (white/yellow)
                    col = mix(col, uLightColor, smoothstep(0.0, 0.3, flame) * uAmbient);
                    // Mid (orange)
                    col = mix(col, uObjectColor, smoothstep(0.2, 0.6, flame));
                    // Outer (red/dark)
                    col = mix(col, uAmbientColor, smoothstep(0.5, 1.0, flame) * 0.5);

                    // Bright core
                    float core = exp(-length(uv) * uShadowSoft);
                    col += uLightColor * core * uSmoothing;

                    // Sparks
                    for (int i = 0; i < 10; i++) {
                        float fi = float(i);
                        vec2 sparkPos = vec2(hash(vec2(fi, t * 0.01)) - 0.5, fract(t * 0.5 + hash(vec2(fi, 0.0))));
                        sparkPos.x *= uSphereRadius;
                        sparkPos.y = sparkPos.y * 2.0 - 1.0;
                        float d = length(uv - sparkPos);
                        col += uLightColor * exp(-d * 50.0) * 0.5;
                    }

                    col = pow(max(col, 0.0), vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 23: Quantum Foam - Spacetime bubbles
            quantumFoam: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec2 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                vec2 hash2(vec2 p) {
                    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);
                }

                float voronoi(vec2 p) {
                    vec2 n = floor(p);
                    vec2 f = fract(p);
                    float md = 8.0;
                    for (int i = -1; i <= 1; i++) {
                        for (int j = -1; j <= 1; j++) {
                            vec2 g = vec2(float(i), float(j));
                            vec2 o = hash2(n + g);
                            vec2 r = g + o - f;
                            float d = dot(r, r);
                            md = min(md, d);
                        }
                    }
                    return sqrt(md);
                }

                void main() {
                    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;
                    float t = iTime * uSpeed + uTimeOffset;

                    uv *= uZoom;

                    vec3 col = uBgColor;

                    // Multiple scales of foam
                    float foam = 0.0;
                    float edge = 0.0;

                    for (int i = 0; i < 4; i++) {
                        float fi = float(i);
                        float scale = uSpikeLength * (2.0 + fi * 2.0);
                        vec2 animUV = uv * scale + t * (0.1 + fi * 0.05) * vec2(1.0, 0.5);

                        float v = voronoi(animUV);

                        // Bubble interior
                        foam += (1.0 - v) * (1.0 / (1.0 + fi));

                        // Cell edges
                        edge += exp(-v * uShadowSoft * (5.0 + fi * 2.0)) * (1.0 / (1.0 + fi * 0.5));
                    }

                    // Pulsing effect
                    float pulse = 0.8 + 0.2 * sin(t * 2.0);

                    // Color composition
                    col += uAmbientColor * foam * uAmbient * 0.5;
                    col += uObjectColor * edge * uDiffuse * pulse;

                    // Bright spots (virtual particles)
                    for (int i = 0; i < 15; i++) {
                        float fi = float(i);
                        vec2 particlePos = hash2(vec2(fi, floor(t * 2.0 + fi * 0.1))) * 2.0 - 1.0;
                        particlePos *= uSphereRadius;
                        float lifetime = fract(t * 0.5 + fi * 0.1);
                        float brightness = sin(lifetime * 3.14159) * (1.0 - lifetime);
                        float d = length(uv - particlePos);
                        col += uLightColor * exp(-d * 30.0) * brightness * uSmoothing;
                    }

                    // Energy fluctuation overlay
                    float energy = sin(uv.x * uShellThickness * 20.0 + t) * sin(uv.y * uShellThickness * 20.0 - t * 1.3);
                    col += uLightColor * energy * 0.1 * uSmoothing;

                    col = pow(max(col, 0.0), vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 24: Tesseract - 4D hypercube projection
            tesseract: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec2 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                mat2 rot(float a) {
                    float c = cos(a), s = sin(a);
                    return mat2(c, -s, s, c);
                }

                float line(vec2 p, vec2 a, vec2 b) {
                    vec2 pa = p - a, ba = b - a;
                    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
                    return length(pa - ba * h);
                }

                void main() {
                    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;
                    float t = iTime * uSpeed + uTimeOffset;

                    uv *= uZoom;

                    vec3 col = uBgColor;

                    // 4D rotation angles
                    float a1 = t * 0.5;
                    float a2 = t * 0.3;
                    float a3 = t * 0.4;

                    // 16 vertices of tesseract in 4D, projected to 2D
                    float edgeGlow = 0.0;
                    float vertexGlow = 0.0;

                    // Generate cube vertices
                    for (int i = 0; i < 16; i++) {
                        // 4D coordinates from binary representation
                        float x = float((i & 1) * 2 - 1) * uSphereRadius * 0.5;
                        float y = float(((i >> 1) & 1) * 2 - 1) * uSphereRadius * 0.5;
                        float z = float(((i >> 2) & 1) * 2 - 1) * uSphereRadius * 0.5;
                        float w = float(((i >> 3) & 1) * 2 - 1) * uSphereRadius * 0.5;

                        // 4D rotations (XW and YZ planes)
                        float nx = x * cos(a1) - w * sin(a1);
                        float nw = x * sin(a1) + w * cos(a1);
                        x = nx; w = nw;

                        float ny = y * cos(a2) - z * sin(a2);
                        float nz = y * sin(a2) + z * cos(a2);
                        y = ny; z = nz;

                        // XY rotation
                        nx = x * cos(a3) - y * sin(a3);
                        ny = x * sin(a3) + y * cos(a3);
                        x = nx; y = ny;

                        // Perspective projection from 4D to 2D
                        float scale = uFov / (uFov + w + z * 0.5);
                        vec2 p = vec2(x, y) * scale;

                        // Vertex glow
                        float d = length(uv - p);
                        float depth = 0.5 + 0.5 * (w + z) / (uSphereRadius * 2.0);
                        vertexGlow += exp(-d * uShadowSoft * 10.0) * (0.5 + depth * 0.5);

                        // Draw edges to connected vertices
                        for (int j = 0; j < 16; j++) {
                            // Check if vertices differ by exactly one bit (connected in hypercube)
                            int diff = i ^ j;
                            if (diff == 1 || diff == 2 || diff == 4 || diff == 8) {
                                float x2 = float((j & 1) * 2 - 1) * uSphereRadius * 0.5;
                                float y2 = float(((j >> 1) & 1) * 2 - 1) * uSphereRadius * 0.5;
                                float z2 = float(((j >> 2) & 1) * 2 - 1) * uSphereRadius * 0.5;
                                float w2 = float(((j >> 3) & 1) * 2 - 1) * uSphereRadius * 0.5;

                                // Apply same rotations
                                float nx2 = x2 * cos(a1) - w2 * sin(a1);
                                float nw2 = x2 * sin(a1) + w2 * cos(a1);
                                x2 = nx2; w2 = nw2;

                                float ny2 = y2 * cos(a2) - z2 * sin(a2);
                                float nz2 = y2 * sin(a2) + z2 * cos(a2);
                                y2 = ny2; z2 = nz2;

                                nx2 = x2 * cos(a3) - y2 * sin(a3);
                                ny2 = x2 * sin(a3) + y2 * cos(a3);
                                x2 = nx2; y2 = ny2;

                                float scale2 = uFov / (uFov + w2 + z2 * 0.5);
                                vec2 p2 = vec2(x2, y2) * scale2;

                                float lineDist = line(uv, p, p2);
                                float depth2 = 0.5 + 0.5 * (w2 + z2) / (uSphereRadius * 2.0);
                                edgeGlow += exp(-lineDist * uShadowSoft * 30.0) * (depth + depth2) * 0.25 * uSpikeWidth;
                            }
                        }
                    }

                    // Compose
                    col += uObjectColor * edgeGlow * uAmbient;
                    col += uLightColor * vertexGlow * uDiffuse * 0.5;

                    // Inner glow
                    float innerGlow = exp(-length(uv) * uShellThickness * 3.0);
                    col += uAmbientColor * innerGlow * uSmoothing * 0.5;

                    col = pow(max(col, 0.0), vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 25: Digital Rain - Matrix-style falling code
            digitalRain: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec2 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                float hash(float n) { return fract(sin(n) * 43758.5453); }
                float hash2(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }

                float char(vec2 p, float n) {
                    // Simple pseudo-character pattern
                    p = fract(p);
                    float h = hash(n + floor(p.x * 3.0) + floor(p.y * 5.0) * 3.0);
                    return step(0.5, h) * step(0.1, p.x) * step(p.x, 0.9) * step(0.1, p.y) * step(p.y, 0.9);
                }

                void main() {
                    vec2 uv = gl_FragCoord.xy / iResolution.xy;
                    float t = iTime * uSpeed + uTimeOffset;

                    vec3 col = uBgColor;

                    // Column settings
                    float columns = uSpikeLength * 30.0;
                    float colWidth = 1.0 / columns;

                    // Current column
                    float colIndex = floor(uv.x * columns);
                    float colX = fract(uv.x * columns);

                    // Multiple rain layers for depth
                    for (int layer = 0; layer < 3; layer++) {
                        float fl = float(layer);
                        float layerOffset = fl * 13.7;

                        // Rain drop for this column
                        float dropSpeed = (0.5 + hash(colIndex + layerOffset) * 0.5) * uShellThickness;
                        float dropStart = hash(colIndex + 100.0 + layerOffset);
                        float dropPos = fract(dropStart + t * dropSpeed);

                        // Trail length
                        float trailLen = uSphereRadius * 0.3 * (0.5 + hash(colIndex + 200.0 + layerOffset) * 0.5);

                        // Distance from drop head
                        float distFromHead = dropPos - uv.y;
                        if (distFromHead < 0.0) distFromHead += 1.0;

                        // Character grid
                        float charRows = uShadowSoft * 3.0;
                        float charY = floor(uv.y * charRows);
                        float localY = fract(uv.y * charRows);

                        // Is this cell in the trail?
                        float inTrail = step(distFromHead, trailLen) * step(0.0, distFromHead);

                        // Brightness fade along trail
                        float brightness = (1.0 - distFromHead / trailLen) * inTrail;
                        brightness = pow(brightness, 1.5);

                        // Character flickering
                        float charSeed = colIndex * 100.0 + charY + floor(t * (3.0 + hash(colIndex) * 5.0));
                        float charPattern = hash2(vec2(colIndex, charY + floor(t * 2.0)));

                        // Make head brightest
                        float headDist = abs(distFromHead);
                        float headGlow = exp(-headDist * charRows * 2.0);

                        // Layer depth effect
                        float layerBrightness = 1.0 - fl * 0.3;

                        // Combine
                        float intensity = brightness * charPattern * layerBrightness;
                        intensity += headGlow * 2.0 * layerBrightness;

                        col += uObjectColor * intensity * uAmbient * 0.5;
                        col += uLightColor * headGlow * uDiffuse * layerBrightness;
                    }

                    // Glow effect
                    float glow = 0.0;
                    for (float i = -2.0; i <= 2.0; i++) {
                        float neighborCol = floor(uv.x * columns) + i;
                        float dropSpeed = (0.5 + hash(neighborCol) * 0.5) * uShellThickness;
                        float dropPos = fract(hash(neighborCol + 100.0) + t * dropSpeed);
                        float dist = abs(uv.y - dropPos);
                        glow += exp(-dist * 10.0) * exp(-abs(i) * 2.0);
                    }
                    col += uLightColor * glow * uSmoothing * 0.1;

                    col = pow(max(col, 0.0), vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 26: Nebula Core - Explosive nebula center
            nebulaCore: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec2 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                float hash(vec2 p) { return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453); }

                float noise(vec2 p) {
                    vec2 i = floor(p);
                    vec2 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    return mix(mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),
                               mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x), f.y);
                }

                float fbm(vec2 p) {
                    float f = 0.0;
                    float w = 0.5;
                    for (int i = 0; i < 6; i++) {
                        f += w * noise(p);
                        p *= 2.0;
                        w *= 0.5;
                    }
                    return f;
                }

                void main() {
                    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;
                    float t = iTime * uSpeed + uTimeOffset;

                    uv *= uZoom;

                    float angle = atan(uv.y, uv.x);
                    float radius = length(uv);

                    // Explosion shockwaves
                    float shockwave = 0.0;
                    for (int i = 0; i < 3; i++) {
                        float fi = float(i);
                        float waveRadius = fract(t * 0.2 + fi * 0.33) * uSphereRadius * 2.0;
                        float wave = exp(-abs(radius - waveRadius) * uShadowSoft * 5.0);
                        wave *= (1.0 - fract(t * 0.2 + fi * 0.33)); // Fade as it expands
                        shockwave += wave;
                    }

                    // Turbulent core
                    vec2 turbUV = uv;
                    turbUV += vec2(fbm(uv * 3.0 + t * 0.5), fbm(uv * 3.0 + 10.0 - t * 0.4)) * uShellThickness * 0.5;

                    float core = fbm(turbUV * uSpikeLength * 2.0 + t * 0.3);
                    core *= exp(-radius * 3.0);

                    // Filaments
                    float filaments = 0.0;
                    for (int i = 0; i < 8; i++) {
                        float fi = float(i);
                        float fAngle = fi * 0.785 + t * 0.1;
                        vec2 dir = vec2(cos(fAngle), sin(fAngle));
                        float proj = dot(uv, dir);
                        float perp = length(uv - dir * proj);

                        float turbulence = fbm(vec2(proj * 10.0, fi) + t * 0.5) * 0.1;
                        float filament = exp(-(perp + turbulence) * uShadowSoft * 10.0);
                        filament *= smoothstep(0.0, 0.2, proj) * smoothstep(uSphereRadius, 0.3, proj);
                        filaments += filament;
                    }

                    // Hot gas clouds
                    float gas1 = fbm(uv * 4.0 + t * 0.2);
                    float gas2 = fbm(uv * 6.0 - t * 0.15 + 20.0);

                    // Color composition
                    vec3 col = uBgColor;

                    // Background nebula
                    col += uAmbientColor * gas1 * 0.3 * uAmbient;
                    col += uObjectColor * gas2 * 0.4;

                    // Shockwaves
                    col += uLightColor * shockwave * uDiffuse;

                    // Filaments
                    col += uObjectColor * filaments * 0.8;
                    col += uLightColor * filaments * 0.3;

                    // Hot core
                    col += uLightColor * core * 2.0 * uDiffuse;

                    // Central star
                    float star = exp(-radius * uShadowSoft * 8.0);
                    col += vec3(1.0, 0.95, 0.9) * star * uSmoothing * 2.0;

                    col = pow(max(col, 0.0), vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 27: Crystal Cavern - Crystalline formations
            crystalCavern: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec2 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                vec2 hash2(vec2 p) {
                    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);
                }

                float voronoi(vec2 p, out vec2 cellCenter) {
                    vec2 n = floor(p);
                    vec2 f = fract(p);
                    float md = 8.0;
                    vec2 mr;
                    for (int i = -1; i <= 1; i++) {
                        for (int j = -1; j <= 1; j++) {
                            vec2 g = vec2(float(i), float(j));
                            vec2 o = hash2(n + g);
                            vec2 r = g + o - f;
                            float d = dot(r, r);
                            if (d < md) {
                                md = d;
                                mr = r;
                                cellCenter = n + g + o;
                            }
                        }
                    }
                    return sqrt(md);
                }

                void main() {
                    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;
                    float t = iTime * uSpeed + uTimeOffset;

                    uv *= uZoom;

                    vec3 col = uBgColor;

                    // Multiple crystal layers
                    for (int layer = 0; layer < 4; layer++) {
                        float fl = float(layer);
                        float scale = uSpikeLength * (3.0 + fl * 2.0);

                        // Animate position slightly
                        vec2 animUV = uv * scale;
                        animUV += vec2(sin(t * 0.2 + fl), cos(t * 0.15 + fl * 2.0)) * 0.3;

                        vec2 cellCenter;
                        float v = voronoi(animUV, cellCenter);

                        // Crystal facet effect
                        float facet = dot(normalize(uv - cellCenter / scale), vec2(cos(t + fl), sin(t + fl)));
                        facet = facet * 0.5 + 0.5;

                        // Edge highlighting
                        float edge = 1.0 - smoothstep(0.0, uSpikeWidth * 0.2, v);

                        // Inner glow per crystal
                        float inner = exp(-v * uShadowSoft * 3.0);

                        // Refraction-like color shift
                        vec3 crystalCol = uObjectColor;
                        crystalCol = mix(crystalCol, uLightColor, facet * 0.5);
                        crystalCol = mix(crystalCol, uAmbientColor, (1.0 - facet) * 0.3);

                        // Shimmer
                        float shimmer = sin(cellCenter.x * 10.0 + t * 3.0) * sin(cellCenter.y * 10.0 - t * 2.5);
                        shimmer = shimmer * 0.5 + 0.5;

                        float layerOpacity = 1.0 / (1.0 + fl * 0.5);

                        col += crystalCol * inner * uAmbient * layerOpacity * 0.3;
                        col += uLightColor * edge * uDiffuse * layerOpacity * 0.5;
                        col += uLightColor * shimmer * inner * uSmoothing * layerOpacity * 0.2;
                    }

                    // Ambient light rays
                    float rays = 0.0;
                    for (int i = 0; i < 5; i++) {
                        float fi = float(i);
                        float rayAngle = fi * 0.628 + t * 0.1;
                        vec2 rayDir = vec2(cos(rayAngle), sin(rayAngle));
                        float rayDist = abs(dot(uv, vec2(-rayDir.y, rayDir.x)));
                        rays += exp(-rayDist * uShellThickness * 10.0) * 0.2;
                    }
                    col += uLightColor * rays * uSmoothing * 0.3;

                    // Dust particles
                    for (int i = 0; i < 20; i++) {
                        float fi = float(i);
                        vec2 dustPos = hash2(vec2(fi, fi * 1.3)) * 2.0 - 1.0;
                        dustPos *= uSphereRadius;
                        dustPos += vec2(sin(t + fi), cos(t * 0.7 + fi)) * 0.2;
                        float d = length(uv - dustPos);
                        float twinkle = sin(t * 3.0 + fi * 5.0) * 0.5 + 0.5;
                        col += vec3(1.0) * exp(-d * 100.0) * twinkle * 0.5;
                    }

                    col = pow(max(col, 0.0), vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `,

            // Shader 28: Infinity Mirror - Recursive reflections
            infinityMirror: `
                precision highp float;
                uniform vec2 iResolution;
                uniform float iTime;
                uniform vec2 iMouse;
                uniform float uSpeed;
                uniform float uTimeOffset;
                uniform float uZoom;
                uniform float uFov;
                uniform float uCamHeight;
                uniform float uSpikeLength;
                uniform float uSpikeWidth;
                uniform float uShellThickness;
                uniform float uSphereRadius;
                uniform float uSmoothing;
                uniform vec3 uLightDir;
                uniform float uAmbient;
                uniform float uDiffuse;
                uniform float uShadowSoft;
                uniform vec3 uObjectColor;
                uniform vec3 uLightColor;
                uniform vec3 uAmbientColor;
                uniform vec3 uBgColor;

                mat2 rot(float a) {
                    float c = cos(a), s = sin(a);
                    return mat2(c, -s, s, c);
                }

                void main() {
                    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;
                    float t = iTime * uSpeed + uTimeOffset;

                    vec3 col = uBgColor;

                    // Multiple recursive layers
                    for (int i = 0; i < 12; i++) {
                        float fi = float(i);

                        // Scale down for each recursion
                        float scale = pow(uShellThickness + 0.7, fi) * uZoom;
                        vec2 layerUV = uv * scale;

                        // Rotate each layer slightly
                        layerUV = rot(t * 0.2 + fi * 0.1) * layerUV;

                        // Tunnel depth offset
                        layerUV += vec2(sin(t * 0.3 + fi * 0.5), cos(t * 0.25 + fi * 0.5)) * 0.1 * uCamHeight;

                        // Frame/mirror border
                        vec2 absUV = abs(layerUV);
                        float frame = max(absUV.x, absUV.y);

                        float outerEdge = uSphereRadius;
                        float innerEdge = outerEdge - uSpikeWidth * 0.15;

                        // Frame glow
                        float frameGlow = smoothstep(outerEdge, innerEdge, frame) * (1.0 - smoothstep(innerEdge - 0.02, innerEdge, frame));

                        // Neon edge
                        float neonEdge = exp(-abs(frame - outerEdge) * uShadowSoft * 20.0);

                        // Color varies by depth
                        vec3 layerColor = uObjectColor;
                        layerColor = mix(layerColor, uLightColor, sin(fi * 0.5 + t) * 0.5 + 0.5);
                        layerColor = mix(layerColor, uAmbientColor, cos(fi * 0.3 + t * 0.7) * 0.5 + 0.5);

                        // Depth fade
                        float depthFade = 1.0 / (1.0 + fi * 0.2);

                        // Corner decorations
                        float corner = 0.0;
                        for (int c = 0; c < 4; c++) {
                            float ca = float(c) * 1.5708 + 0.785; // 45 degree offset corners
                            vec2 cornerPos = vec2(cos(ca), sin(ca)) * outerEdge * 0.9;
                            float d = length(layerUV - cornerPos);
                            corner += exp(-d * uShadowSoft * 15.0);
                        }

                        col += layerColor * frameGlow * uAmbient * depthFade * 0.5;
                        col += layerColor * neonEdge * uDiffuse * depthFade * 0.3;
                        col += uLightColor * corner * uSmoothing * depthFade * 0.2;
                    }

                    // Center light source
                    float centerGlow = exp(-length(uv) * uSpikeLength * 2.0);
                    col += uLightColor * centerGlow * uDiffuse;

                    // Pulsing effect
                    float pulse = 0.8 + 0.2 * sin(t * 2.0);
                    col *= pulse;

                    // Chromatic aberration at edges
                    float dist = length(uv);
                    float aberration = smoothstep(0.3, 0.8, dist) * 0.02 * uSmoothing;
                    col.r *= 1.0 + aberration;
                    col.b *= 1.0 - aberration;

                    col = pow(max(col, 0.0), vec3(1.0 / 2.2));
                    gl_FragColor = vec4(col, 1.0);
                }
            `
        };

        // ============================================
        // PRESETS DATA
        // ============================================

        const presets = {
            0: [ // Fractal Orb
                { name: 'Default', speed: 1, timeOffset: 0, zoom: 4, fov: 2, camHeight: 1, spikeLength: 1, spikeWidth: 0.05, shellThickness: 0.02, sphereRadius: 1, smoothing: 0.12, lightX: -0.6, lightY: 0.7, lightZ: 0.5, ambient: 0.8, diffuse: 1.2, shadowSoft: 8, objectColor: '#8866aa', lightColor: '#ddbbff', ambientColor: '#443366', bgColor: '#080510' },
                { name: 'Alien', speed: 0.8, timeOffset: 0, zoom: 3.5, fov: 2.2, camHeight: 1.2, spikeLength: 1.2, spikeWidth: 0.05, shellThickness: 0.015, sphereRadius: 0.9, smoothing: 0.1, lightX: -0.4, lightY: 0.8, lightZ: 0.5, ambient: 1, diffuse: 1.4, shadowSoft: 10, objectColor: '#44aa66', lightColor: '#88ffaa', ambientColor: '#224433', bgColor: '#000805' },
                { name: 'Crystal', speed: 0.5, timeOffset: 0, zoom: 4.5, fov: 1.8, camHeight: 0.8, spikeLength: 0.8, spikeWidth: 0.05, shellThickness: 0.01, sphereRadius: 1.1, smoothing: 0.08, lightX: 0.5, lightY: 0.9, lightZ: -0.2, ambient: 1.3, diffuse: 1.8, shadowSoft: 15, objectColor: '#aaccff', lightColor: '#ffffff', ambientColor: '#5577aa', bgColor: '#050a18' },
                { name: 'Fire', speed: 1.5, timeOffset: 0, zoom: 3.8, fov: 2, camHeight: 1, spikeLength: 1.3, spikeWidth: 0.05, shellThickness: 0.025, sphereRadius: 0.85, smoothing: 0.15, lightX: -0.5, lightY: 0.5, lightZ: 0.7, ambient: 0.6, diffuse: 2, shadowSoft: 5, objectColor: '#ff5522', lightColor: '#ffbb66', ambientColor: '#551100', bgColor: '#0a0300' },
                { name: 'Ice', speed: 0.3, timeOffset: 0, zoom: 5, fov: 2.5, camHeight: 1.5, spikeLength: 0.7, spikeWidth: 0.05, shellThickness: 0.008, sphereRadius: 1.2, smoothing: 0.05, lightX: 0.7, lightY: 0.6, lightZ: 0.4, ambient: 1.5, diffuse: 0.9, shadowSoft: 18, objectColor: '#bbddff', lightColor: '#ffffff', ambientColor: '#7799bb', bgColor: '#030810' },
                { name: 'Neon', speed: 2, timeOffset: 0, zoom: 3, fov: 1.5, camHeight: 0.5, spikeLength: 1.5, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.3, smoothing: 0.2, lightX: -0.8, lightY: 0.3, lightZ: 0.5, ambient: 0.4, diffuse: 2.5, shadowSoft: 3, objectColor: '#ff00aa', lightColor: '#00ffcc', ambientColor: '#880055', bgColor: '#050005' },
                { name: 'Void', speed: 0.15, timeOffset: 5, zoom: 6, fov: 3, camHeight: 2, spikeLength: 0.5, spikeWidth: 0.05, shellThickness: 0.005, sphereRadius: 1.5, smoothing: 0.02, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.25, diffuse: 0.4, shadowSoft: 1, objectColor: '#222233', lightColor: '#444455', ambientColor: '#111122', bgColor: '#000000' },
                { name: 'Gold', speed: 0.7, timeOffset: 0, zoom: 4.2, fov: 2, camHeight: 1, spikeLength: 0.9, spikeWidth: 0.05, shellThickness: 0.018, sphereRadius: 1, smoothing: 0.1, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.7, diffuse: 1.5, shadowSoft: 10, objectColor: '#ccaa55', lightColor: '#ffeebb', ambientColor: '#775522', bgColor: '#080503' },
                { name: 'Matrix', speed: 1.2, timeOffset: 2, zoom: 3.8, fov: 2.2, camHeight: 0.8, spikeLength: 1.1, spikeWidth: 0.05, shellThickness: 0.015, sphereRadius: 0.95, smoothing: 0.08, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.85, diffuse: 1.6, shadowSoft: 8, objectColor: '#00dd44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000600' }
            ],
            1: [ // Plasma Sphere
                { name: 'Default', speed: 1, timeOffset: 0, zoom: 4, fov: 2, camHeight: 1, spikeLength: 0.3, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.12, lightX: -0.6, lightY: 0.7, lightZ: 0.5, ambient: 0.8, diffuse: 1.2, shadowSoft: 8, objectColor: '#ff6688', lightColor: '#ffccdd', ambientColor: '#6644aa', bgColor: '#0a0510' },
                { name: 'Alien', speed: 1.5, timeOffset: 0, zoom: 3.5, fov: 2, camHeight: 1, spikeLength: 0.5, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.2, smoothing: 0.12, lightX: -0.6, lightY: 0.7, lightZ: 0.5, ambient: 1, diffuse: 1.5, shadowSoft: 8, objectColor: '#44ff88', lightColor: '#aaffcc', ambientColor: '#226644', bgColor: '#000a05' },
                { name: 'Crystal', speed: 0.5, timeOffset: 0, zoom: 4.5, fov: 2.5, camHeight: 1, spikeLength: 0.2, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 0.8, smoothing: 0.12, lightX: 0.5, lightY: 0.8, lightZ: -0.3, ambient: 1.2, diffuse: 1.8, shadowSoft: 12, objectColor: '#88ccff', lightColor: '#ffffff', ambientColor: '#4488aa', bgColor: '#050a15' },
                { name: 'Fire', speed: 2, timeOffset: 0, zoom: 3.8, fov: 1.8, camHeight: 1, spikeLength: 0.4, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.1, smoothing: 0.15, lightX: -0.4, lightY: 0.5, lightZ: 0.7, ambient: 0.6, diffuse: 2, shadowSoft: 6, objectColor: '#ff4400', lightColor: '#ffaa66', ambientColor: '#661100', bgColor: '#0a0300' },
                { name: 'Ice', speed: 0.3, timeOffset: 0, zoom: 5, fov: 2.2, camHeight: 1, spikeLength: 0.15, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 0.9, smoothing: 0.08, lightX: 0.6, lightY: 0.7, lightZ: 0.4, ambient: 1.4, diffuse: 1, shadowSoft: 15, objectColor: '#aaeeff', lightColor: '#ffffff', ambientColor: '#4488bb', bgColor: '#000810' },
                { name: 'Neon', speed: 3, timeOffset: 0, zoom: 3, fov: 1.5, camHeight: 1, spikeLength: 0.6, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.3, smoothing: 0.2, lightX: -0.8, lightY: 0.4, lightZ: 0.5, ambient: 0.5, diffuse: 2.5, shadowSoft: 4, objectColor: '#ff00ff', lightColor: '#00ffff', ambientColor: '#880088', bgColor: '#050008' },
                { name: 'Void', speed: 0.2, timeOffset: 3, zoom: 6, fov: 3, camHeight: 1, spikeLength: 0.1, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.5, smoothing: 0.05, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.3, diffuse: 0.4, shadowSoft: 2, objectColor: '#333344', lightColor: '#555566', ambientColor: '#222233', bgColor: '#000000' },
                { name: 'Gold', speed: 0.8, timeOffset: 0, zoom: 4.2, fov: 2, camHeight: 1, spikeLength: 0.35, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.1, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.7, diffuse: 1.4, shadowSoft: 10, objectColor: '#ddaa44', lightColor: '#ffeeaa', ambientColor: '#886622', bgColor: '#080500' },
                { name: 'Matrix', speed: 1.5, timeOffset: 1, zoom: 3.8, fov: 2, camHeight: 1, spikeLength: 0.4, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.12, lightX: -0.3, lightY: 0.8, lightZ: 0.5, ambient: 0.8, diffuse: 1.6, shadowSoft: 8, objectColor: '#00ff44', lightColor: '#88ffaa', ambientColor: '#004411', bgColor: '#000500' }
            ],
            2: [ // Icosahedron Spikes
                { name: 'Default', speed: 1, timeOffset: 0, zoom: 4, fov: 2, camHeight: 1, spikeLength: 1.3, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.12, lightX: -0.6, lightY: 0.7, lightZ: 0.5, ambient: 0.8, diffuse: 1.2, shadowSoft: 8, objectColor: '#808080', lightColor: '#f2cc99', ambientColor: '#80b3cc', bgColor: '#0a0b0d' },
                { name: 'Alien', speed: 0.5, timeOffset: 0, zoom: 3.5, fov: 2.2, camHeight: 1.2, spikeLength: 2, spikeWidth: 0.03, shellThickness: 0.02, sphereRadius: 0.8, smoothing: 0.08, lightX: -0.3, lightY: 0.8, lightZ: 0.6, ambient: 1, diffuse: 1.5, shadowSoft: 12, objectColor: '#2a5a3a', lightColor: '#66ff99', ambientColor: '#003322', bgColor: '#000505' },
                { name: 'Crystal', speed: 0.3, timeOffset: 0, zoom: 3, fov: 1.8, camHeight: 0.8, spikeLength: 1.8, spikeWidth: 0.02, shellThickness: 0.015, sphereRadius: 1.2, smoothing: 0.05, lightX: 0.5, lightY: 0.9, lightZ: -0.3, ambient: 1.2, diffuse: 2, shadowSoft: 15, objectColor: '#88ccff', lightColor: '#ffffff', ambientColor: '#4488cc', bgColor: '#0a1020' },
                { name: 'Fire', speed: 1.5, timeOffset: 0, zoom: 4.5, fov: 2, camHeight: 1, spikeLength: 1.5, spikeWidth: 0.08, shellThickness: 0.04, sphereRadius: 0.9, smoothing: 0.15, lightX: -0.4, lightY: 0.5, lightZ: 0.7, ambient: 0.6, diffuse: 1.8, shadowSoft: 6, objectColor: '#ff4422', lightColor: '#ffaa44', ambientColor: '#440000', bgColor: '#100500' },
                { name: 'Ice', speed: 0.2, timeOffset: 0, zoom: 3.8, fov: 2.5, camHeight: 1.5, spikeLength: 2.2, spikeWidth: 0.015, shellThickness: 0.01, sphereRadius: 1.1, smoothing: 0.03, lightX: 0.7, lightY: 0.6, lightZ: 0.4, ambient: 1.5, diffuse: 0.8, shadowSoft: 20, objectColor: '#aaddff', lightColor: '#eeffff', ambientColor: '#6699bb', bgColor: '#051015' },
                { name: 'Neon', speed: 2, timeOffset: 0, zoom: 5, fov: 1.5, camHeight: 0.5, spikeLength: 1, spikeWidth: 0.1, shellThickness: 0.05, sphereRadius: 1.3, smoothing: 0.2, lightX: -0.8, lightY: 0.3, lightZ: 0.5, ambient: 0.4, diffuse: 2.5, shadowSoft: 4, objectColor: '#ff00ff', lightColor: '#00ffff', ambientColor: '#ff0088', bgColor: '#050005' },
                { name: 'Void', speed: 0.1, timeOffset: 5, zoom: 6, fov: 3, camHeight: 2, spikeLength: 0.5, spikeWidth: 0.12, shellThickness: 0.08, sphereRadius: 1.5, smoothing: 0.25, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.3, diffuse: 0.5, shadowSoft: 2, objectColor: '#222233', lightColor: '#444466', ambientColor: '#111122', bgColor: '#000000' },
                { name: 'Gold', speed: 0.8, timeOffset: 0, zoom: 4, fov: 2, camHeight: 1, spikeLength: 1.4, spikeWidth: 0.06, shellThickness: 0.035, sphereRadius: 1, smoothing: 0.1, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.7, diffuse: 1.4, shadowSoft: 10, objectColor: '#cc9944', lightColor: '#ffeecc', ambientColor: '#664422', bgColor: '#0a0805' },
                { name: 'Matrix', speed: 1.2, timeOffset: 2, zoom: 3.5, fov: 2.2, camHeight: 0.8, spikeLength: 1.6, spikeWidth: 0.04, shellThickness: 0.025, sphereRadius: 0.95, smoothing: 0.08, lightX: -0.2, lightY: 0.9, lightZ: 0.4, ambient: 0.9, diffuse: 1.6, shadowSoft: 8, objectColor: '#00ff00', lightColor: '#88ff88', ambientColor: '#003300', bgColor: '#000800' }
            ],
            3: [ // Crystal Matrix (same preset structure)
                { name: 'Default', speed: 1, timeOffset: 0, zoom: 4, fov: 2, camHeight: 1, spikeLength: 0.5, spikeWidth: 0.08, shellThickness: 0.03, sphereRadius: 2, smoothing: 0.12, lightX: -0.6, lightY: 0.7, lightZ: 0.5, ambient: 0.8, diffuse: 1.2, shadowSoft: 8, objectColor: '#66aacc', lightColor: '#aaddff', ambientColor: '#335566', bgColor: '#050810' },
                { name: 'Alien', speed: 1.2, timeOffset: 0, zoom: 3.5, fov: 2.2, camHeight: 1.2, spikeLength: 0.6, spikeWidth: 0.06, shellThickness: 0.02, sphereRadius: 1.8, smoothing: 0.1, lightX: -0.4, lightY: 0.8, lightZ: 0.5, ambient: 1, diffuse: 1.5, shadowSoft: 10, objectColor: '#44cc88', lightColor: '#88ffbb', ambientColor: '#225544', bgColor: '#000a08' },
                { name: 'Crystal', speed: 0.6, timeOffset: 0, zoom: 4.5, fov: 1.8, camHeight: 0.8, spikeLength: 0.4, spikeWidth: 0.04, shellThickness: 0.015, sphereRadius: 2.2, smoothing: 0.06, lightX: 0.5, lightY: 0.9, lightZ: -0.2, ambient: 1.4, diffuse: 1.8, shadowSoft: 15, objectColor: '#99ccff', lightColor: '#ffffff', ambientColor: '#4477aa', bgColor: '#030815' },
                { name: 'Fire', speed: 1.8, timeOffset: 0, zoom: 3.8, fov: 2, camHeight: 1, spikeLength: 0.7, spikeWidth: 0.1, shellThickness: 0.04, sphereRadius: 1.6, smoothing: 0.18, lightX: -0.5, lightY: 0.5, lightZ: 0.7, ambient: 0.5, diffuse: 2.2, shadowSoft: 5, objectColor: '#ff6633', lightColor: '#ffcc88', ambientColor: '#662200', bgColor: '#0a0400' },
                { name: 'Ice', speed: 0.4, timeOffset: 0, zoom: 5, fov: 2.5, camHeight: 1.5, spikeLength: 0.35, spikeWidth: 0.03, shellThickness: 0.01, sphereRadius: 2.4, smoothing: 0.04, lightX: 0.7, lightY: 0.6, lightZ: 0.4, ambient: 1.6, diffuse: 0.8, shadowSoft: 18, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#6699cc', bgColor: '#020610' },
                { name: 'Neon', speed: 2.5, timeOffset: 0, zoom: 3, fov: 1.5, camHeight: 0.5, spikeLength: 0.8, spikeWidth: 0.12, shellThickness: 0.05, sphereRadius: 1.5, smoothing: 0.22, lightX: -0.8, lightY: 0.3, lightZ: 0.5, ambient: 0.3, diffuse: 2.8, shadowSoft: 3, objectColor: '#ff44ff', lightColor: '#44ffff', ambientColor: '#880088', bgColor: '#080008' },
                { name: 'Void', speed: 0.2, timeOffset: 4, zoom: 6, fov: 3, camHeight: 2, spikeLength: 0.25, spikeWidth: 0.15, shellThickness: 0.08, sphereRadius: 3, smoothing: 0.25, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.2, diffuse: 0.35, shadowSoft: 1, objectColor: '#333344', lightColor: '#555566', ambientColor: '#222233', bgColor: '#000000' },
                { name: 'Gold', speed: 0.9, timeOffset: 0, zoom: 4.2, fov: 2, camHeight: 1, spikeLength: 0.55, spikeWidth: 0.07, shellThickness: 0.025, sphereRadius: 2, smoothing: 0.1, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.7, diffuse: 1.4, shadowSoft: 10, objectColor: '#ddbb66', lightColor: '#ffeecc', ambientColor: '#886633', bgColor: '#0a0805' },
                { name: 'Matrix', speed: 1.4, timeOffset: 1.5, zoom: 3.8, fov: 2.2, camHeight: 0.8, spikeLength: 0.65, spikeWidth: 0.05, shellThickness: 0.02, sphereRadius: 1.9, smoothing: 0.08, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.85, diffuse: 1.7, shadowSoft: 8, objectColor: '#22ff55', lightColor: '#99ffaa', ambientColor: '#004422', bgColor: '#000800' }
            ],
            4: [ // Neon Wireframe - Optimized presets
                { name: 'Default', speed: 1, timeOffset: 0, zoom: 4, fov: 2, camHeight: 1, spikeLength: 1, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.1, lightX: -0.6, lightY: 0.7, lightZ: 0.5, ambient: 0.8, diffuse: 1.2, shadowSoft: 8, objectColor: '#ff00ff', lightColor: '#00ffff', ambientColor: '#880088', bgColor: '#050008' },
                { name: 'Alien', speed: 1.3, timeOffset: 0, zoom: 3.5, fov: 2.2, camHeight: 1.2, spikeLength: 1, spikeWidth: 0.04, shellThickness: 0.025, sphereRadius: 0.9, smoothing: 0.08, lightX: -0.4, lightY: 0.8, lightZ: 0.5, ambient: 1, diffuse: 1.5, shadowSoft: 10, objectColor: '#00ff88', lightColor: '#88ffcc', ambientColor: '#004422', bgColor: '#000808' },
                { name: 'Crystal', speed: 0.5, timeOffset: 0, zoom: 4.5, fov: 1.8, camHeight: 0.8, spikeLength: 1, spikeWidth: 0.03, shellThickness: 0.015, sphereRadius: 1.1, smoothing: 0.05, lightX: 0.5, lightY: 0.9, lightZ: -0.2, ambient: 1.3, diffuse: 1.8, shadowSoft: 15, objectColor: '#88ddff', lightColor: '#ffffff', ambientColor: '#4488bb', bgColor: '#030812' },
                { name: 'Fire', speed: 2, timeOffset: 0, zoom: 3.8, fov: 2, camHeight: 1, spikeLength: 1, spikeWidth: 0.07, shellThickness: 0.04, sphereRadius: 0.85, smoothing: 0.15, lightX: -0.5, lightY: 0.5, lightZ: 0.7, ambient: 0.5, diffuse: 2.2, shadowSoft: 5, objectColor: '#ff4400', lightColor: '#ffaa44', ambientColor: '#551100', bgColor: '#080200' },
                { name: 'Ice', speed: 0.5, timeOffset: 0, zoom: 4, fov: 2, camHeight: 1, spikeLength: 0.9, spikeWidth: 0.04, shellThickness: 0.02, sphereRadius: 1, smoothing: 0.08, lightX: 0.7, lightY: 0.6, lightZ: 0.4, ambient: 1.3, diffuse: 1.0, shadowSoft: 12, objectColor: '#aaeeff', lightColor: '#ffffff', ambientColor: '#5599bb', bgColor: '#020610' },
                { name: 'Neon', speed: 2, timeOffset: 0, zoom: 3.5, fov: 1.8, camHeight: 0.8, spikeLength: 1, spikeWidth: 0.06, shellThickness: 0.04, sphereRadius: 1, smoothing: 0.12, lightX: -0.8, lightY: 0.3, lightZ: 0.5, ambient: 0.4, diffuse: 2.5, shadowSoft: 5, objectColor: '#ff00aa', lightColor: '#00ffaa', ambientColor: '#880055', bgColor: '#080005' },
                { name: 'Void', speed: 0.3, timeOffset: 2, zoom: 4.5, fov: 2.2, camHeight: 1.2, spikeLength: 0.8, spikeWidth: 0.05, shellThickness: 0.04, sphereRadius: 1.1, smoothing: 0.1, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.3, diffuse: 0.5, shadowSoft: 3, objectColor: '#444466', lightColor: '#666688', ambientColor: '#222244', bgColor: '#000000' },
                { name: 'Gold', speed: 0.8, timeOffset: 0, zoom: 4, fov: 2, camHeight: 1, spikeLength: 1, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.1, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.7, diffuse: 1.4, shadowSoft: 10, objectColor: '#ffaa00', lightColor: '#ffddaa', ambientColor: '#884400', bgColor: '#080500' },
                { name: 'Matrix', speed: 1.2, timeOffset: 1, zoom: 3.8, fov: 2, camHeight: 0.9, spikeLength: 1, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.1, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.8, diffuse: 1.6, shadowSoft: 8, objectColor: '#00ff00', lightColor: '#88ff88', ambientColor: '#003300', bgColor: '#000600' }
            ],
            5: [ // Cyberpunk City - Optimized presets
                { name: 'Default', speed: 0.5, timeOffset: 0, zoom: 4, fov: 2, camHeight: 1.0, spikeLength: 1.0, spikeWidth: 0.05, shellThickness: 0.05, sphereRadius: 1, smoothing: 0.1, lightX: -0.5, lightY: 0.8, lightZ: 0.5, ambient: 0.5, diffuse: 1.5, shadowSoft: 8, objectColor: '#222233', lightColor: '#00ffff', ambientColor: '#110022', bgColor: '#050010' },
                { name: 'Neon District', speed: 0.6, timeOffset: 0, zoom: 4, fov: 2, camHeight: 0.8, spikeLength: 1.0, spikeWidth: 0.05, shellThickness: 0.05, sphereRadius: 1, smoothing: 0.1, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.3, diffuse: 1.8, shadowSoft: 6, objectColor: '#002200', lightColor: '#00ff00', ambientColor: '#001100', bgColor: '#000000' },
                { name: 'Sunset', speed: 0.4, timeOffset: 0, zoom: 4.2, fov: 1.9, camHeight: 1.2, spikeLength: 0.9, spikeWidth: 0.05, shellThickness: 0.04, sphereRadius: 1, smoothing: 0.1, lightX: 0.8, lightY: 0.4, lightZ: -0.2, ambient: 0.5, diffuse: 1.3, shadowSoft: 10, objectColor: '#331122', lightColor: '#ffaa00', ambientColor: '#440022', bgColor: '#110011' },
                { name: 'Midnight', speed: 0.5, timeOffset: 2, zoom: 4, fov: 2, camHeight: 1.0, spikeLength: 1.0, spikeWidth: 0.05, shellThickness: 0.05, sphereRadius: 1, smoothing: 0.1, lightX: -0.3, lightY: 0.6, lightZ: 0.5, ambient: 0.4, diffuse: 1.4, shadowSoft: 8, objectColor: '#1a1a2e', lightColor: '#ff00aa', ambientColor: '#0a0a15', bgColor: '#000008' },
                { name: 'Ice', speed: 0.3, timeOffset: 0, zoom: 4.5, fov: 2.2, camHeight: 1.3, spikeLength: 0.8, spikeWidth: 0.05, shellThickness: 0.04, sphereRadius: 1, smoothing: 0.08, lightX: 0.6, lightY: 0.7, lightZ: 0.4, ambient: 0.7, diffuse: 1.0, shadowSoft: 14, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#4488aa', bgColor: '#020610' },
                { name: 'Neon', speed: 0.7, timeOffset: 0, zoom: 3.8, fov: 1.8, camHeight: 0.7, spikeLength: 1.1, spikeWidth: 0.05, shellThickness: 0.05, sphereRadius: 1, smoothing: 0.12, lightX: -0.7, lightY: 0.4, lightZ: 0.5, ambient: 0.35, diffuse: 2.2, shadowSoft: 5, objectColor: '#ff00dd', lightColor: '#00ffaa', ambientColor: '#770066', bgColor: '#080005' },
                { name: 'Void', speed: 0.25, timeOffset: 3, zoom: 4.8, fov: 2.5, camHeight: 1.5, spikeLength: 0.7, spikeWidth: 0.05, shellThickness: 0.04, sphereRadius: 1.1, smoothing: 0.06, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.25, diffuse: 0.5, shadowSoft: 3, objectColor: '#333355', lightColor: '#555577', ambientColor: '#1a1a33', bgColor: '#000000' },
                { name: 'Gold', speed: 0.5, timeOffset: 0, zoom: 4.2, fov: 2, camHeight: 1.0, spikeLength: 0.95, spikeWidth: 0.05, shellThickness: 0.05, sphereRadius: 1, smoothing: 0.1, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.6, diffuse: 1.4, shadowSoft: 10, objectColor: '#ddaa33', lightColor: '#ffeeaa', ambientColor: '#775511', bgColor: '#080500' },
                { name: 'Matrix', speed: 0.6, timeOffset: 1.5, zoom: 4, fov: 2, camHeight: 0.9, spikeLength: 1.0, spikeWidth: 0.05, shellThickness: 0.05, sphereRadius: 1, smoothing: 0.1, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.4, diffuse: 1.7, shadowSoft: 7, objectColor: '#00ee44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000600' }
            ],
            6: [ // Liquid Metal - Optimized presets
                { name: 'Chrome', speed: 1.0, timeOffset: 0, zoom: 3.5, fov: 2, camHeight: 0, spikeLength: 0.8, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.1, smoothing: 0.12, lightX: 0.5, lightY: 0.8, lightZ: 0.5, ambient: 0.7, diffuse: 1.0, shadowSoft: 12, objectColor: '#cccccc', lightColor: '#ffffff', ambientColor: '#888899', bgColor: '#222222' },
                { name: 'Gold', speed: 0.8, timeOffset: 0, zoom: 3.5, fov: 2, camHeight: 0, spikeLength: 0.7, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.1, smoothing: 0.12, lightX: -0.5, lightY: 0.6, lightZ: 0.4, ambient: 0.6, diffuse: 1.2, shadowSoft: 10, objectColor: '#aa8822', lightColor: '#ffeeaa', ambientColor: '#442200', bgColor: '#110800' },
                { name: 'Mercury', speed: 1.2, timeOffset: 0, zoom: 3.2, fov: 2, camHeight: 0, spikeLength: 1.0, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.1, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.5, diffuse: 1.5, shadowSoft: 15, objectColor: '#8888aa', lightColor: '#ccddff', ambientColor: '#444455', bgColor: '#050510' },
                { name: 'Obsidian', speed: 0.7, timeOffset: 0, zoom: 3.5, fov: 2, camHeight: 0, spikeLength: 0.6, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.1, smoothing: 0.1, lightX: 0.3, lightY: 0.9, lightZ: 0.3, ambient: 0.4, diffuse: 1.3, shadowSoft: 8, objectColor: '#333344', lightColor: '#8888ff', ambientColor: '#222233', bgColor: '#0a0a15' },
                { name: 'Copper', speed: 0.9, timeOffset: 0, zoom: 3.5, fov: 2, camHeight: 0, spikeLength: 0.9, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.1, smoothing: 0.1, lightX: -0.4, lightY: 0.7, lightZ: 0.5, ambient: 0.5, diffuse: 1.3, shadowSoft: 10, objectColor: '#cc7744', lightColor: '#ffddbb', ambientColor: '#553322', bgColor: '#100805' },
                { name: 'Neon', speed: 1.5, timeOffset: 0, zoom: 3.2, fov: 1.8, camHeight: 0, spikeLength: 1.1, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.12, lightX: -0.8, lightY: 0.4, lightZ: 0.5, ambient: 0.4, diffuse: 2.0, shadowSoft: 5, objectColor: '#ff00cc', lightColor: '#00ffee', ambientColor: '#880066', bgColor: '#080008' },
                { name: 'Void', speed: 0.4, timeOffset: 2, zoom: 4, fov: 2.3, camHeight: 0, spikeLength: 0.5, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.2, smoothing: 0.08, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.25, diffuse: 0.6, shadowSoft: 3, objectColor: '#2a2a3a', lightColor: '#4a4a5a', ambientColor: '#151525', bgColor: '#000000' },
                { name: 'Ice', speed: 0.6, timeOffset: 0, zoom: 3.8, fov: 2.1, camHeight: 0, spikeLength: 0.7, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.1, smoothing: 0.1, lightX: 0.6, lightY: 0.7, lightZ: 0.4, ambient: 0.8, diffuse: 1.1, shadowSoft: 14, objectColor: '#bbddff', lightColor: '#ffffff', ambientColor: '#6699bb', bgColor: '#030810' },
                { name: 'Matrix', speed: 1.0, timeOffset: 1, zoom: 3.5, fov: 2, camHeight: 0, spikeLength: 0.85, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.1, smoothing: 0.1, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.5, diffuse: 1.5, shadowSoft: 8, objectColor: '#00dd44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000600' }
            ],
            7: [ // Quantum Flux - Optimized presets
                { name: 'Entangled', speed: 0.8, timeOffset: 0, zoom: 4, fov: 2, camHeight: 0.5, spikeLength: 0.8, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.1, smoothing: 0.1, lightX: 0.5, lightY: 0.8, lightZ: 0.3, ambient: 0.6, diffuse: 1.3, shadowSoft: 10, objectColor: '#6644ff', lightColor: '#ff44ff', ambientColor: '#331188', bgColor: '#0a0015' },
                { name: 'Superposition', speed: 1.0, timeOffset: 0, zoom: 3.8, fov: 2, camHeight: 0.4, spikeLength: 1.0, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.1, lightX: -0.3, lightY: 0.9, lightZ: 0.4, ambient: 0.7, diffuse: 1.4, shadowSoft: 8, objectColor: '#44ffaa', lightColor: '#88ffff', ambientColor: '#226655', bgColor: '#000a08' },
                { name: 'Collapse', speed: 1.5, timeOffset: 0, zoom: 3.5, fov: 1.9, camHeight: 0.3, spikeLength: 1.2, spikeWidth: 0.06, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.12, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.5, diffuse: 1.8, shadowSoft: 6, objectColor: '#ff4466', lightColor: '#ffaacc', ambientColor: '#661133', bgColor: '#100008' },
                { name: 'Uncertainty', speed: 0.6, timeOffset: 1, zoom: 4.2, fov: 2, camHeight: 0.6, spikeLength: 0.6, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.1, smoothing: 0.1, lightX: 0.6, lightY: 0.6, lightZ: 0.6, ambient: 0.7, diffuse: 1.1, shadowSoft: 12, objectColor: '#aaaaff', lightColor: '#ffffff', ambientColor: '#555588', bgColor: '#050510' },
                { name: 'Ice', speed: 0.4, timeOffset: 0, zoom: 4.3, fov: 2.2, camHeight: 0.7, spikeLength: 0.7, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.1, smoothing: 0.08, lightX: 0.7, lightY: 0.65, lightZ: 0.35, ambient: 0.85, diffuse: 1.0, shadowSoft: 14, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#5588aa', bgColor: '#020610' },
                { name: 'Neon', speed: 1.3, timeOffset: 0, zoom: 3.6, fov: 1.8, camHeight: 0.35, spikeLength: 1.1, spikeWidth: 0.06, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.13, lightX: -0.75, lightY: 0.35, lightZ: 0.55, ambient: 0.4, diffuse: 2.2, shadowSoft: 5, objectColor: '#ff00bb', lightColor: '#00ffcc', ambientColor: '#880066', bgColor: '#080005' },
                { name: 'Void', speed: 0.3, timeOffset: 2.5, zoom: 4.6, fov: 2.4, camHeight: 0.8, spikeLength: 0.5, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.2, smoothing: 0.06, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.2, diffuse: 0.45, shadowSoft: 2, objectColor: '#333355', lightColor: '#555577', ambientColor: '#1a1a33', bgColor: '#000000' },
                { name: 'Gold', speed: 0.7, timeOffset: 0, zoom: 4, fov: 2, camHeight: 0.5, spikeLength: 0.85, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.1, smoothing: 0.1, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.65, diffuse: 1.35, shadowSoft: 10, objectColor: '#ddaa44', lightColor: '#ffeeaa', ambientColor: '#775522', bgColor: '#080500' },
                { name: 'Matrix', speed: 1.1, timeOffset: 1.2, zoom: 3.8, fov: 2, camHeight: 0.45, spikeLength: 0.95, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.1, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.55, diffuse: 1.6, shadowSoft: 8, objectColor: '#00ee44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000600' }
            ],
            8: [ // Void Tendrils - Optimized presets
                { name: 'Abyss', speed: 0.6, timeOffset: 0, zoom: 4.5, fov: 2, camHeight: 0.5, spikeLength: 1.2, spikeWidth: 0.05, shellThickness: 0.04, sphereRadius: 1.0, smoothing: 0.1, lightX: 0, lightY: 0.8, lightZ: 0.5, ambient: 0.4, diffuse: 1.4, shadowSoft: 6, objectColor: '#4400aa', lightColor: '#aa00ff', ambientColor: '#220055', bgColor: '#000005' },
                { name: 'Eldritch', speed: 0.5, timeOffset: 0, zoom: 5, fov: 2, camHeight: 0.4, spikeLength: 1.5, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 0.9, smoothing: 0.1, lightX: -0.5, lightY: 0.5, lightZ: 0.5, ambient: 0.3, diffuse: 1.6, shadowSoft: 5, objectColor: '#00aa44', lightColor: '#44ff88', ambientColor: '#004422', bgColor: '#000500' },
                { name: 'Cosmic Horror', speed: 0.4, timeOffset: 2, zoom: 5, fov: 2.2, camHeight: 0.6, spikeLength: 1.0, spikeWidth: 0.05, shellThickness: 0.04, sphereRadius: 1.1, smoothing: 0.1, lightX: 0.3, lightY: 0.9, lightZ: 0.3, ambient: 0.45, diffuse: 1.2, shadowSoft: 8, objectColor: '#664488', lightColor: '#cc88ff', ambientColor: '#332244', bgColor: '#050008' },
                { name: 'Singularity', speed: 0.8, timeOffset: 0, zoom: 4.5, fov: 2, camHeight: 0.3, spikeLength: 0.9, spikeWidth: 0.05, shellThickness: 0.04, sphereRadius: 1.2, smoothing: 0.1, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.2, diffuse: 2.0, shadowSoft: 4, objectColor: '#ffffff', lightColor: '#88ffff', ambientColor: '#444466', bgColor: '#000000' },
                { name: 'Ice', speed: 0.35, timeOffset: 0, zoom: 4.8, fov: 2.2, camHeight: 0.6, spikeLength: 1.0, spikeWidth: 0.05, shellThickness: 0.035, sphereRadius: 1.05, smoothing: 0.08, lightX: 0.65, lightY: 0.7, lightZ: 0.35, ambient: 0.7, diffuse: 1.0, shadowSoft: 14, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#5588aa', bgColor: '#020610' },
                { name: 'Neon', speed: 0.9, timeOffset: 0, zoom: 4.2, fov: 1.9, camHeight: 0.4, spikeLength: 1.3, spikeWidth: 0.055, shellThickness: 0.04, sphereRadius: 1, smoothing: 0.12, lightX: -0.7, lightY: 0.4, lightZ: 0.55, ambient: 0.35, diffuse: 2.0, shadowSoft: 5, objectColor: '#ff00cc', lightColor: '#00ffaa', ambientColor: '#880066', bgColor: '#080005' },
                { name: 'Void', speed: 0.25, timeOffset: 3, zoom: 5.2, fov: 2.5, camHeight: 0.7, spikeLength: 0.8, spikeWidth: 0.05, shellThickness: 0.04, sphereRadius: 1.15, smoothing: 0.06, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.15, diffuse: 0.4, shadowSoft: 2, objectColor: '#222244', lightColor: '#444466', ambientColor: '#111133', bgColor: '#000000' },
                { name: 'Gold', speed: 0.55, timeOffset: 0, zoom: 4.5, fov: 2, camHeight: 0.5, spikeLength: 1.1, spikeWidth: 0.05, shellThickness: 0.04, sphereRadius: 1, smoothing: 0.1, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.55, diffuse: 1.4, shadowSoft: 10, objectColor: '#ddaa44', lightColor: '#ffeeaa', ambientColor: '#775522', bgColor: '#080500' },
                { name: 'Matrix', speed: 0.7, timeOffset: 1.5, zoom: 4.5, fov: 2, camHeight: 0.45, spikeLength: 1.15, spikeWidth: 0.05, shellThickness: 0.04, sphereRadius: 1, smoothing: 0.1, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.4, diffuse: 1.6, shadowSoft: 7, objectColor: '#00ee44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000600' }
            ],
            9: [ // Prismatic Storm - Optimized presets
                { name: 'Rainbow', speed: 0.9, timeOffset: 0, zoom: 4, fov: 2, camHeight: 0.5, spikeLength: 0.9, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.1, smoothing: 0.1, lightX: 0.5, lightY: 0.8, lightZ: 0.3, ambient: 0.7, diffuse: 1.3, shadowSoft: 10, objectColor: '#ff8844', lightColor: '#ffffff', ambientColor: '#884422', bgColor: '#0a0508' },
                { name: 'Aurora', speed: 0.7, timeOffset: 0, zoom: 4.5, fov: 2, camHeight: 0.6, spikeLength: 0.7, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.2, smoothing: 0.1, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.75, diffuse: 1.1, shadowSoft: 12, objectColor: '#44ff88', lightColor: '#88ffff', ambientColor: '#226644', bgColor: '#000a08' },
                { name: 'Diamond', speed: 0.5, timeOffset: 0, zoom: 4, fov: 1.9, camHeight: 0.4, spikeLength: 0.6, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.0, smoothing: 0.08, lightX: 0.7, lightY: 0.7, lightZ: 0, ambient: 0.9, diffuse: 1.8, shadowSoft: 15, objectColor: '#aaccff', lightColor: '#ffffff', ambientColor: '#5577aa', bgColor: '#050815' },
                { name: 'Chaos', speed: 1.5, timeOffset: 0, zoom: 3.8, fov: 1.8, camHeight: 0.3, spikeLength: 1.0, spikeWidth: 0.06, shellThickness: 0.04, sphereRadius: 1, smoothing: 0.12, lightX: -0.5, lightY: 0.5, lightZ: 0.5, ambient: 0.55, diffuse: 1.6, shadowSoft: 6, objectColor: '#ff4488', lightColor: '#ffff44', ambientColor: '#882244', bgColor: '#100010' },
                { name: 'Ice', speed: 0.4, timeOffset: 0, zoom: 4.3, fov: 2.1, camHeight: 0.55, spikeLength: 0.75, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.1, smoothing: 0.08, lightX: 0.65, lightY: 0.7, lightZ: 0.35, ambient: 0.85, diffuse: 1.0, shadowSoft: 14, objectColor: '#bbddff', lightColor: '#ffffff', ambientColor: '#6699bb', bgColor: '#020610' },
                { name: 'Neon', speed: 1.2, timeOffset: 0, zoom: 3.7, fov: 1.85, camHeight: 0.35, spikeLength: 0.95, spikeWidth: 0.055, shellThickness: 0.035, sphereRadius: 1.05, smoothing: 0.12, lightX: -0.75, lightY: 0.35, lightZ: 0.55, ambient: 0.4, diffuse: 2.1, shadowSoft: 5, objectColor: '#ff00dd', lightColor: '#00ffbb', ambientColor: '#880066', bgColor: '#080005' },
                { name: 'Void', speed: 0.3, timeOffset: 2.5, zoom: 4.7, fov: 2.4, camHeight: 0.7, spikeLength: 0.6, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.15, smoothing: 0.06, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.2, diffuse: 0.5, shadowSoft: 2, objectColor: '#333355', lightColor: '#555577', ambientColor: '#1a1a33', bgColor: '#000000' },
                { name: 'Gold', speed: 0.65, timeOffset: 0, zoom: 4.1, fov: 2, camHeight: 0.5, spikeLength: 0.8, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.1, smoothing: 0.1, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.65, diffuse: 1.35, shadowSoft: 10, objectColor: '#ddaa44', lightColor: '#ffeeaa', ambientColor: '#775522', bgColor: '#080500' },
                { name: 'Matrix', speed: 1.0, timeOffset: 1.2, zoom: 3.9, fov: 2, camHeight: 0.45, spikeLength: 0.85, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.05, smoothing: 0.1, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.5, diffuse: 1.55, shadowSoft: 8, objectColor: '#00ee44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000600' }
            ],
            10: [ // Biomech Entity - Optimized presets
                { name: 'Organic', speed: 0.8, timeOffset: 0, zoom: 4.5, fov: 2, camHeight: 0.5, spikeLength: 1.0, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.0, smoothing: 0.1, lightX: 0.4, lightY: 0.8, lightZ: 0.4, ambient: 0.55, diffuse: 1.4, shadowSoft: 10, objectColor: '#884455', lightColor: '#ffaacc', ambientColor: '#442233', bgColor: '#0a0508' },
                { name: 'Synthetic', speed: 1.0, timeOffset: 0, zoom: 4.2, fov: 2, camHeight: 0.4, spikeLength: 1.2, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.1, smoothing: 0.1, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.6, diffuse: 1.5, shadowSoft: 8, objectColor: '#448888', lightColor: '#88ffff', ambientColor: '#224444', bgColor: '#000a0a' },
                { name: 'Xenomorph', speed: 0.6, timeOffset: 0, zoom: 4.8, fov: 2, camHeight: 0.6, spikeLength: 1.5, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 0.9, smoothing: 0.1, lightX: -0.3, lightY: 0.6, lightZ: 0.6, ambient: 0.4, diffuse: 1.6, shadowSoft: 6, objectColor: '#334455', lightColor: '#88aacc', ambientColor: '#112233', bgColor: '#000508' },
                { name: 'Hive Mind', speed: 1.2, timeOffset: 0, zoom: 4, fov: 2, camHeight: 0.3, spikeLength: 0.8, spikeWidth: 0.06, shellThickness: 0.04, sphereRadius: 1.1, smoothing: 0.1, lightX: 0.5, lightY: 0.5, lightZ: 0.5, ambient: 0.45, diffuse: 1.4, shadowSoft: 10, objectColor: '#aa6622', lightColor: '#ffcc88', ambientColor: '#553311', bgColor: '#080500' },
                { name: 'Ice', speed: 0.45, timeOffset: 0, zoom: 4.6, fov: 2.15, camHeight: 0.55, spikeLength: 0.9, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.0, smoothing: 0.08, lightX: 0.65, lightY: 0.7, lightZ: 0.35, ambient: 0.75, diffuse: 1.05, shadowSoft: 14, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#5588aa', bgColor: '#020610' },
                { name: 'Neon', speed: 1.1, timeOffset: 0, zoom: 4.1, fov: 1.9, camHeight: 0.35, spikeLength: 1.1, spikeWidth: 0.055, shellThickness: 0.035, sphereRadius: 1.05, smoothing: 0.12, lightX: -0.7, lightY: 0.4, lightZ: 0.55, ambient: 0.4, diffuse: 2.0, shadowSoft: 5, objectColor: '#ff00cc', lightColor: '#00ffaa', ambientColor: '#880066', bgColor: '#080005' },
                { name: 'Void', speed: 0.35, timeOffset: 2.5, zoom: 5, fov: 2.3, camHeight: 0.65, spikeLength: 0.7, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.1, smoothing: 0.06, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.2, diffuse: 0.45, shadowSoft: 2, objectColor: '#2a2a44', lightColor: '#4a4a66', ambientColor: '#151533', bgColor: '#000000' },
                { name: 'Gold', speed: 0.7, timeOffset: 0, zoom: 4.4, fov: 2, camHeight: 0.5, spikeLength: 0.95, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.0, smoothing: 0.1, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.6, diffuse: 1.4, shadowSoft: 10, objectColor: '#ddaa44', lightColor: '#ffeeaa', ambientColor: '#775522', bgColor: '#080500' },
                { name: 'Matrix', speed: 0.9, timeOffset: 1.2, zoom: 4.3, fov: 2, camHeight: 0.4, spikeLength: 1.0, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1.05, smoothing: 0.1, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.5, diffuse: 1.55, shadowSoft: 8, objectColor: '#00ee44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000600' }
            ],
            11: [ // Fractal Cosmos - Deep space fractals
                { name: 'Deep Space', speed: 0.5, timeOffset: 0, zoom: 10, fov: 1, camHeight: 1, spikeLength: 1.0, spikeWidth: 0.1, shellThickness: 0.29, sphereRadius: 1, smoothing: 0.15, lightX: 0, lightY: 1, lightZ: 0, ambient: 1.2, diffuse: 1.5, shadowSoft: 8, objectColor: '#ff4488', lightColor: '#88ffff', ambientColor: '#440044', bgColor: '#000008' },
                { name: 'Nebula', speed: 0.3, timeOffset: 2, zoom: 12, fov: 1, camHeight: 1, spikeLength: 1.5, spikeWidth: 0.15, shellThickness: 0.25, sphereRadius: 1, smoothing: 0.2, lightX: 0.5, lightY: 0.8, lightZ: 0.3, ambient: 1.0, diffuse: 1.8, shadowSoft: 10, objectColor: '#ff66aa', lightColor: '#aaffff', ambientColor: '#330033', bgColor: '#050010' },
                { name: 'Cosmic Fire', speed: 0.8, timeOffset: 0, zoom: 8, fov: 1, camHeight: 1, spikeLength: 0.8, spikeWidth: 0.08, shellThickness: 0.3, sphereRadius: 1, smoothing: 0.1, lightX: -0.5, lightY: 0.5, lightZ: 0.5, ambient: 0.8, diffuse: 2.0, shadowSoft: 5, objectColor: '#ff6622', lightColor: '#ffaa44', ambientColor: '#441100', bgColor: '#080200' },
                { name: 'Ice Crystal', speed: 0.4, timeOffset: 0, zoom: 11, fov: 1, camHeight: 1, spikeLength: 1.2, spikeWidth: 0.12, shellThickness: 0.27, sphereRadius: 1, smoothing: 0.18, lightX: 0.6, lightY: 0.7, lightZ: 0.4, ambient: 1.4, diffuse: 1.2, shadowSoft: 12, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#334466', bgColor: '#020610' },
                { name: 'Void Walker', speed: 0.2, timeOffset: 5, zoom: 15, fov: 1, camHeight: 1, spikeLength: 0.6, spikeWidth: 0.05, shellThickness: 0.32, sphereRadius: 1, smoothing: 0.08, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.4, diffuse: 0.6, shadowSoft: 3, objectColor: '#333355', lightColor: '#555577', ambientColor: '#111133', bgColor: '#000000' },
                { name: 'Neon Galaxy', speed: 0.6, timeOffset: 0, zoom: 9, fov: 1, camHeight: 1, spikeLength: 1.1, spikeWidth: 0.13, shellThickness: 0.28, sphereRadius: 1, smoothing: 0.16, lightX: -0.7, lightY: 0.4, lightZ: 0.5, ambient: 0.6, diffuse: 2.2, shadowSoft: 4, objectColor: '#ff00ff', lightColor: '#00ffaa', ambientColor: '#660066', bgColor: '#080005' },
                { name: 'Gold Rush', speed: 0.5, timeOffset: 0, zoom: 10, fov: 1, camHeight: 1, spikeLength: 1.0, spikeWidth: 0.1, shellThickness: 0.29, sphereRadius: 1, smoothing: 0.14, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.9, diffuse: 1.6, shadowSoft: 8, objectColor: '#ddaa44', lightColor: '#ffeeaa', ambientColor: '#553311', bgColor: '#080500' },
                { name: 'Matrix Code', speed: 0.7, timeOffset: 1, zoom: 9, fov: 1, camHeight: 1, spikeLength: 0.9, spikeWidth: 0.09, shellThickness: 0.3, sphereRadius: 1, smoothing: 0.12, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.7, diffuse: 1.8, shadowSoft: 6, objectColor: '#00ff44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000800' },
                { name: 'Alien', speed: 0.45, timeOffset: 0, zoom: 11, fov: 1, camHeight: 1, spikeLength: 1.3, spikeWidth: 0.11, shellThickness: 0.26, sphereRadius: 1, smoothing: 0.17, lightX: 0.3, lightY: 0.9, lightZ: 0.3, ambient: 1.1, diffuse: 1.4, shadowSoft: 9, objectColor: '#44ff88', lightColor: '#aaffcc', ambientColor: '#114422', bgColor: '#000a05' }
            ],
            12: [ // Plasma Vortex - Swirling energy
                { name: 'Default', speed: 0.5, timeOffset: 0, zoom: 8, fov: 1, camHeight: 1, spikeLength: 1.0, spikeWidth: 0.05, shellThickness: 0.08, sphereRadius: 1, smoothing: 0.1, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.8, diffuse: 1.5, shadowSoft: 8, objectColor: '#ff6688', lightColor: '#88ffff', ambientColor: '#442244', bgColor: '#050008' },
                { name: 'Solar Flare', speed: 0.8, timeOffset: 0, zoom: 6, fov: 1, camHeight: 1, spikeLength: 1.2, spikeWidth: 0.08, shellThickness: 0.1, sphereRadius: 1, smoothing: 0.12, lightX: 0.5, lightY: 0.5, lightZ: 0.5, ambient: 0.6, diffuse: 2.0, shadowSoft: 5, objectColor: '#ff4400', lightColor: '#ffaa44', ambientColor: '#551100', bgColor: '#100500' },
                { name: 'Electric Blue', speed: 0.6, timeOffset: 0, zoom: 7, fov: 1, camHeight: 1, spikeLength: 0.8, spikeWidth: 0.04, shellThickness: 0.07, sphereRadius: 1, smoothing: 0.08, lightX: 0, lightY: 0.8, lightZ: 0.6, ambient: 1.0, diffuse: 1.8, shadowSoft: 10, objectColor: '#4488ff', lightColor: '#aaddff', ambientColor: '#112244', bgColor: '#000510' },
                { name: 'Toxic', speed: 0.7, timeOffset: 2, zoom: 7, fov: 1, camHeight: 1, spikeLength: 1.1, spikeWidth: 0.06, shellThickness: 0.09, sphereRadius: 1, smoothing: 0.11, lightX: -0.4, lightY: 0.7, lightZ: 0.5, ambient: 0.9, diffuse: 1.6, shadowSoft: 7, objectColor: '#66ff44', lightColor: '#aaffaa', ambientColor: '#224411', bgColor: '#000800' },
                { name: 'Ice Storm', speed: 0.4, timeOffset: 0, zoom: 9, fov: 1, camHeight: 1, spikeLength: 0.7, spikeWidth: 0.03, shellThickness: 0.06, sphereRadius: 1, smoothing: 0.06, lightX: 0.6, lightY: 0.7, lightZ: 0.4, ambient: 1.3, diffuse: 1.1, shadowSoft: 14, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#5588aa', bgColor: '#020610' },
                { name: 'Neon Chaos', speed: 0.9, timeOffset: 0, zoom: 5, fov: 1, camHeight: 1, spikeLength: 1.3, spikeWidth: 0.09, shellThickness: 0.11, sphereRadius: 1, smoothing: 0.14, lightX: -0.8, lightY: 0.3, lightZ: 0.5, ambient: 0.5, diffuse: 2.5, shadowSoft: 3, objectColor: '#ff00cc', lightColor: '#00ffaa', ambientColor: '#880066', bgColor: '#080005' },
                { name: 'Void Spiral', speed: 0.25, timeOffset: 4, zoom: 10, fov: 1, camHeight: 1, spikeLength: 0.5, spikeWidth: 0.02, shellThickness: 0.05, sphereRadius: 1, smoothing: 0.04, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.3, diffuse: 0.5, shadowSoft: 2, objectColor: '#333355', lightColor: '#555577', ambientColor: '#1a1a33', bgColor: '#000000' },
                { name: 'Gold Plasma', speed: 0.55, timeOffset: 0, zoom: 8, fov: 1, camHeight: 1, spikeLength: 0.9, spikeWidth: 0.05, shellThickness: 0.08, sphereRadius: 1, smoothing: 0.1, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.85, diffuse: 1.5, shadowSoft: 9, objectColor: '#ddaa44', lightColor: '#ffeeaa', ambientColor: '#775522', bgColor: '#080500' },
                { name: 'Matrix Vortex', speed: 0.65, timeOffset: 1.5, zoom: 7, fov: 1, camHeight: 1, spikeLength: 1.0, spikeWidth: 0.055, shellThickness: 0.085, sphereRadius: 1, smoothing: 0.1, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.75, diffuse: 1.7, shadowSoft: 7, objectColor: '#00ee44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000600' }
            ],
            13: [ // Neon Boxes - Geometric neon
                { name: 'Default', speed: 1.0, timeOffset: 0, zoom: 4, fov: 1.5, camHeight: 0, spikeLength: 1.5, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.1, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.6, diffuse: 1.5, shadowSoft: 23, objectColor: '#4466ff', lightColor: '#00ffff', ambientColor: '#112244', bgColor: '#000510' },
                { name: 'Cyber Punk', speed: 1.2, timeOffset: 0, zoom: 3.5, fov: 1.8, camHeight: 0.2, spikeLength: 1.8, spikeWidth: 0.06, shellThickness: 0.04, sphereRadius: 1, smoothing: 0.12, lightX: -0.5, lightY: 0.5, lightZ: 0.5, ambient: 0.4, diffuse: 2.0, shadowSoft: 18, objectColor: '#ff0088', lightColor: '#00ff88', ambientColor: '#440044', bgColor: '#080008' },
                { name: 'Tron', speed: 0.8, timeOffset: 0, zoom: 4.5, fov: 1.3, camHeight: -0.1, spikeLength: 1.2, spikeWidth: 0.04, shellThickness: 0.025, sphereRadius: 1, smoothing: 0.08, lightX: 0.3, lightY: 0.9, lightZ: 0.3, ambient: 0.5, diffuse: 1.8, shadowSoft: 25, objectColor: '#00ccff', lightColor: '#ffffff', ambientColor: '#003366', bgColor: '#000308' },
                { name: 'Fire Grid', speed: 1.5, timeOffset: 0, zoom: 3, fov: 2, camHeight: 0.3, spikeLength: 2.0, spikeWidth: 0.07, shellThickness: 0.05, sphereRadius: 1, smoothing: 0.15, lightX: 0, lightY: 0.5, lightZ: 0.8, ambient: 0.5, diffuse: 2.2, shadowSoft: 15, objectColor: '#ff4400', lightColor: '#ffaa44', ambientColor: '#441100', bgColor: '#100200' },
                { name: 'Ice Cubes', speed: 0.6, timeOffset: 0, zoom: 5, fov: 1.2, camHeight: -0.2, spikeLength: 1.0, spikeWidth: 0.03, shellThickness: 0.02, sphereRadius: 1, smoothing: 0.06, lightX: 0.6, lightY: 0.7, lightZ: 0.4, ambient: 1.0, diffuse: 1.2, shadowSoft: 30, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#5588aa', bgColor: '#020610' },
                { name: 'Neon Pulse', speed: 1.8, timeOffset: 0, zoom: 2.5, fov: 2.2, camHeight: 0.4, spikeLength: 2.2, spikeWidth: 0.08, shellThickness: 0.06, sphereRadius: 1, smoothing: 0.18, lightX: -0.7, lightY: 0.4, lightZ: 0.5, ambient: 0.3, diffuse: 2.8, shadowSoft: 12, objectColor: '#ff00ff', lightColor: '#00ffaa', ambientColor: '#880066', bgColor: '#080005' },
                { name: 'Void Boxes', speed: 0.4, timeOffset: 3, zoom: 6, fov: 1, camHeight: -0.3, spikeLength: 0.8, spikeWidth: 0.025, shellThickness: 0.015, sphereRadius: 1, smoothing: 0.04, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.25, diffuse: 0.6, shadowSoft: 35, objectColor: '#333355', lightColor: '#555577', ambientColor: '#1a1a33', bgColor: '#000000' },
                { name: 'Gold Bars', speed: 0.9, timeOffset: 0, zoom: 4, fov: 1.5, camHeight: 0, spikeLength: 1.4, spikeWidth: 0.05, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.1, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.7, diffuse: 1.6, shadowSoft: 22, objectColor: '#ddaa44', lightColor: '#ffeeaa', ambientColor: '#775522', bgColor: '#080500' },
                { name: 'Matrix Cubes', speed: 1.1, timeOffset: 1, zoom: 3.8, fov: 1.6, camHeight: 0.1, spikeLength: 1.6, spikeWidth: 0.055, shellThickness: 0.035, sphereRadius: 1, smoothing: 0.11, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.55, diffuse: 1.9, shadowSoft: 20, objectColor: '#00ff44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000800' }
            ],
            14: [ // Warp Tunnel - Space tunnel
                { name: 'Default', speed: 0.5, timeOffset: 0, zoom: 4, fov: 1, camHeight: 1, spikeLength: 1.0, spikeWidth: 1.0, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.1, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.8, diffuse: 1.5, shadowSoft: 8, objectColor: '#4466aa', lightColor: '#00aaff', ambientColor: '#223355', bgColor: '#000510' },
                { name: 'Hyperspace', speed: 0.8, timeOffset: 0, zoom: 3, fov: 1.2, camHeight: 1.2, spikeLength: 1.5, spikeWidth: 1.5, shellThickness: 0.04, sphereRadius: 1, smoothing: 0.12, lightX: 0.5, lightY: 0.5, lightZ: 0.5, ambient: 0.6, diffuse: 2.0, shadowSoft: 5, objectColor: '#ffffff', lightColor: '#aaddff', ambientColor: '#444466', bgColor: '#000005' },
                { name: 'Lava Tube', speed: 0.6, timeOffset: 0, zoom: 5, fov: 0.8, camHeight: 0.8, spikeLength: 0.8, spikeWidth: 0.8, shellThickness: 0.025, sphereRadius: 1.2, smoothing: 0.08, lightX: -0.5, lightY: 0.5, lightZ: 0.5, ambient: 0.5, diffuse: 2.2, shadowSoft: 6, objectColor: '#ff4400', lightColor: '#ffaa44', ambientColor: '#441100', bgColor: '#100200' },
                { name: 'Bio Tunnel', speed: 0.4, timeOffset: 2, zoom: 4.5, fov: 1, camHeight: 1, spikeLength: 1.2, spikeWidth: 1.2, shellThickness: 0.035, sphereRadius: 1, smoothing: 0.1, lightX: 0.3, lightY: 0.8, lightZ: 0.5, ambient: 0.7, diffuse: 1.6, shadowSoft: 9, objectColor: '#66aa44', lightColor: '#aaffaa', ambientColor: '#224411', bgColor: '#000800' },
                { name: 'Ice Warp', speed: 0.35, timeOffset: 0, zoom: 5.5, fov: 0.9, camHeight: 0.9, spikeLength: 0.7, spikeWidth: 0.7, shellThickness: 0.02, sphereRadius: 1.1, smoothing: 0.06, lightX: 0.6, lightY: 0.7, lightZ: 0.4, ambient: 1.2, diffuse: 1.0, shadowSoft: 14, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#5588aa', bgColor: '#020610' },
                { name: 'Neon Express', speed: 0.9, timeOffset: 0, zoom: 2.5, fov: 1.3, camHeight: 1.3, spikeLength: 1.8, spikeWidth: 1.8, shellThickness: 0.05, sphereRadius: 0.9, smoothing: 0.15, lightX: -0.7, lightY: 0.4, lightZ: 0.5, ambient: 0.4, diffuse: 2.5, shadowSoft: 4, objectColor: '#ff00cc', lightColor: '#00ffaa', ambientColor: '#880066', bgColor: '#080005' },
                { name: 'Void Transit', speed: 0.2, timeOffset: 5, zoom: 6, fov: 0.7, camHeight: 0.7, spikeLength: 0.5, spikeWidth: 0.5, shellThickness: 0.015, sphereRadius: 1.2, smoothing: 0.04, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.3, diffuse: 0.5, shadowSoft: 2, objectColor: '#333355', lightColor: '#555577', ambientColor: '#1a1a33', bgColor: '#000000' },
                { name: 'Gold Rush', speed: 0.55, timeOffset: 0, zoom: 4, fov: 1, camHeight: 1, spikeLength: 1.0, spikeWidth: 1.0, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.1, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.8, diffuse: 1.6, shadowSoft: 10, objectColor: '#ddaa44', lightColor: '#ffeeaa', ambientColor: '#775522', bgColor: '#080500' },
                { name: 'Matrix Warp', speed: 0.65, timeOffset: 1, zoom: 3.5, fov: 1.1, camHeight: 1.1, spikeLength: 1.3, spikeWidth: 1.3, shellThickness: 0.035, sphereRadius: 1, smoothing: 0.1, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.6, diffuse: 1.8, shadowSoft: 7, objectColor: '#00ff44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000800' }
            ],
            15: [ // Hyperdrive - Star warp
                { name: 'Default', speed: 1.0, timeOffset: 0, zoom: 1, fov: 1, camHeight: 1, spikeLength: 1.0, spikeWidth: 1.0, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.5, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.8, diffuse: 1.5, shadowSoft: 5, objectColor: '#4488ff', lightColor: '#ffffff', ambientColor: '#223366', bgColor: '#000308' },
                { name: 'Lightspeed', speed: 2.0, timeOffset: 0, zoom: 2, fov: 1, camHeight: 1, spikeLength: 2.0, spikeWidth: 1.5, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.3, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.6, diffuse: 2.0, shadowSoft: 3, objectColor: '#88ddff', lightColor: '#ffffff', ambientColor: '#445577', bgColor: '#000208' },
                { name: 'Warp Core', speed: 1.5, timeOffset: 0, zoom: 1.5, fov: 1, camHeight: 1, spikeLength: 1.5, spikeWidth: 1.2, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.4, lightX: 0.5, lightY: 0.5, lightZ: 0.5, ambient: 0.5, diffuse: 2.5, shadowSoft: 4, objectColor: '#ff6622', lightColor: '#ffaa44', ambientColor: '#662200', bgColor: '#100500' },
                { name: 'Nebula Jump', speed: 0.8, timeOffset: 2, zoom: 0.8, fov: 1, camHeight: 1, spikeLength: 0.8, spikeWidth: 0.8, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.6, lightX: 0.3, lightY: 0.8, lightZ: 0.5, ambient: 1.0, diffuse: 1.2, shadowSoft: 8, objectColor: '#aa44ff', lightColor: '#ddaaff', ambientColor: '#442266', bgColor: '#050010' },
                { name: 'Ice Drift', speed: 0.6, timeOffset: 0, zoom: 0.6, fov: 1, camHeight: 1, spikeLength: 0.6, spikeWidth: 0.6, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.7, lightX: 0.6, lightY: 0.7, lightZ: 0.4, ambient: 1.3, diffuse: 1.0, shadowSoft: 10, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#5588aa', bgColor: '#020610' },
                { name: 'Neon Warp', speed: 2.5, timeOffset: 0, zoom: 2.5, fov: 1, camHeight: 1, spikeLength: 2.5, spikeWidth: 2.0, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.2, lightX: -0.7, lightY: 0.4, lightZ: 0.5, ambient: 0.4, diffuse: 3.0, shadowSoft: 2, objectColor: '#ff00ff', lightColor: '#00ffaa', ambientColor: '#880066', bgColor: '#080005' },
                { name: 'Void Jump', speed: 0.4, timeOffset: 5, zoom: 0.4, fov: 1, camHeight: 1, spikeLength: 0.4, spikeWidth: 0.4, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.8, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.3, diffuse: 0.5, shadowSoft: 15, objectColor: '#333355', lightColor: '#555577', ambientColor: '#1a1a33', bgColor: '#000000' },
                { name: 'Gold Stream', speed: 1.2, timeOffset: 0, zoom: 1.2, fov: 1, camHeight: 1, spikeLength: 1.2, spikeWidth: 1.0, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.45, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.9, diffuse: 1.6, shadowSoft: 6, objectColor: '#ddaa44', lightColor: '#ffeeaa', ambientColor: '#775522', bgColor: '#080500' },
                { name: 'Matrix Jump', speed: 1.8, timeOffset: 1, zoom: 1.8, fov: 1, camHeight: 1, spikeLength: 1.8, spikeWidth: 1.4, shellThickness: 0.03, sphereRadius: 1, smoothing: 0.35, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.6, diffuse: 2.0, shadowSoft: 4, objectColor: '#00ff44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000800' }
            ],
            16: [ // Neural Storm - Brain activity
                { name: 'Default', speed: 0.8, timeOffset: 0, zoom: 1.5, fov: 1, camHeight: 1, spikeLength: 0.5, spikeWidth: 1.0, shellThickness: 1.0, sphereRadius: 1, smoothing: 0.5, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.8, diffuse: 1.5, shadowSoft: 8, objectColor: '#6644ff', lightColor: '#88aaff', ambientColor: '#331188', bgColor: '#050010' },
                { name: 'Synaptic', speed: 1.2, timeOffset: 0, zoom: 1.8, fov: 1, camHeight: 1, spikeLength: 0.7, spikeWidth: 1.5, shellThickness: 1.2, sphereRadius: 1.2, smoothing: 0.4, lightX: 0.5, lightY: 0.5, lightZ: 0.5, ambient: 0.6, diffuse: 2.0, shadowSoft: 5, objectColor: '#ff44aa', lightColor: '#ffaadd', ambientColor: '#661144', bgColor: '#100008' },
                { name: 'Neurons', speed: 0.6, timeOffset: 0, zoom: 1.2, fov: 1, camHeight: 1, spikeLength: 0.4, spikeWidth: 0.8, shellThickness: 0.8, sphereRadius: 0.8, smoothing: 0.6, lightX: 0.3, lightY: 0.8, lightZ: 0.5, ambient: 1.0, diffuse: 1.3, shadowSoft: 10, objectColor: '#44ffaa', lightColor: '#aaffdd', ambientColor: '#116644', bgColor: '#000a08' },
                { name: 'Brain Wave', speed: 1.0, timeOffset: 2, zoom: 1.5, fov: 1, camHeight: 1, spikeLength: 0.6, spikeWidth: 1.2, shellThickness: 1.1, sphereRadius: 1.1, smoothing: 0.5, lightX: -0.4, lightY: 0.7, lightZ: 0.5, ambient: 0.7, diffuse: 1.7, shadowSoft: 7, objectColor: '#ffaa44', lightColor: '#ffddaa', ambientColor: '#664411', bgColor: '#0a0500' },
                { name: 'Frost Mind', speed: 0.5, timeOffset: 0, zoom: 1.3, fov: 1, camHeight: 1, spikeLength: 0.35, spikeWidth: 0.7, shellThickness: 0.7, sphereRadius: 0.9, smoothing: 0.65, lightX: 0.6, lightY: 0.7, lightZ: 0.4, ambient: 1.2, diffuse: 1.0, shadowSoft: 12, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#5588aa', bgColor: '#020610' },
                { name: 'Neon Brain', speed: 1.5, timeOffset: 0, zoom: 2.0, fov: 1, camHeight: 1, spikeLength: 0.8, spikeWidth: 1.8, shellThickness: 1.4, sphereRadius: 1.3, smoothing: 0.3, lightX: -0.7, lightY: 0.4, lightZ: 0.5, ambient: 0.4, diffuse: 2.5, shadowSoft: 4, objectColor: '#ff00cc', lightColor: '#00ffaa', ambientColor: '#880066', bgColor: '#080005' },
                { name: 'Void Think', speed: 0.3, timeOffset: 4, zoom: 1.0, fov: 1, camHeight: 1, spikeLength: 0.25, spikeWidth: 0.5, shellThickness: 0.5, sphereRadius: 0.7, smoothing: 0.75, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.25, diffuse: 0.5, shadowSoft: 15, objectColor: '#333355', lightColor: '#555577', ambientColor: '#1a1a33', bgColor: '#000000' },
                { name: 'Gold Mind', speed: 0.7, timeOffset: 0, zoom: 1.4, fov: 1, camHeight: 1, spikeLength: 0.45, spikeWidth: 0.9, shellThickness: 0.9, sphereRadius: 1, smoothing: 0.55, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.85, diffuse: 1.5, shadowSoft: 9, objectColor: '#ddaa44', lightColor: '#ffeeaa', ambientColor: '#775522', bgColor: '#080500' },
                { name: 'Matrix Mind', speed: 1.0, timeOffset: 1, zoom: 1.6, fov: 1, camHeight: 1, spikeLength: 0.55, spikeWidth: 1.1, shellThickness: 1.0, sphereRadius: 1.1, smoothing: 0.48, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.65, diffuse: 1.8, shadowSoft: 6, objectColor: '#00ff44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000800' }
            ],
            17: [ // Cosmic Singularity - Black hole with accretion disk
                { name: 'Event Horizon', speed: 0.3, timeOffset: 0, zoom: 1.5, fov: 1.2, camHeight: 0, spikeLength: 1.0, spikeWidth: 0.8, shellThickness: 0.5, sphereRadius: 1.0, smoothing: 0.5, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.2, diffuse: 2.5, shadowSoft: 3, objectColor: '#000000', lightColor: '#ff6600', ambientColor: '#220000', bgColor: '#000000' },
                { name: 'Accretion Fury', speed: 0.8, timeOffset: 0, zoom: 1.2, fov: 1.5, camHeight: 0.3, spikeLength: 1.5, spikeWidth: 1.2, shellThickness: 0.7, sphereRadius: 0.8, smoothing: 0.3, lightX: 0.5, lightY: 0.5, lightZ: 0.5, ambient: 0.4, diffuse: 3.0, shadowSoft: 5, objectColor: '#ff4400', lightColor: '#ffaa00', ambientColor: '#441100', bgColor: '#050000' },
                { name: 'Quantum Collapse', speed: 0.5, timeOffset: 2, zoom: 2.0, fov: 1.0, camHeight: -0.2, spikeLength: 0.8, spikeWidth: 0.6, shellThickness: 0.4, sphereRadius: 1.2, smoothing: 0.6, lightX: -0.3, lightY: 0.9, lightZ: 0.3, ambient: 0.15, diffuse: 2.0, shadowSoft: 2, objectColor: '#220044', lightColor: '#8844ff', ambientColor: '#110022', bgColor: '#000005' },
                { name: 'Stellar Death', speed: 0.6, timeOffset: 0, zoom: 1.8, fov: 1.3, camHeight: 0.1, spikeLength: 1.2, spikeWidth: 1.0, shellThickness: 0.6, sphereRadius: 0.9, smoothing: 0.4, lightX: 0.4, lightY: 0.6, lightZ: 0.5, ambient: 0.3, diffuse: 2.8, shadowSoft: 4, objectColor: '#ff2200', lightColor: '#ffcc44', ambientColor: '#330500', bgColor: '#020000' },
                { name: 'Void Maw', speed: 0.2, timeOffset: 5, zoom: 2.5, fov: 0.8, camHeight: -0.4, spikeLength: 0.5, spikeWidth: 0.4, shellThickness: 0.3, sphereRadius: 1.5, smoothing: 0.8, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.05, diffuse: 1.0, shadowSoft: 1, objectColor: '#000000', lightColor: '#333355', ambientColor: '#000011', bgColor: '#000000' },
                { name: 'Plasma Jets', speed: 1.0, timeOffset: 0, zoom: 1.0, fov: 1.8, camHeight: 0.5, spikeLength: 2.0, spikeWidth: 1.5, shellThickness: 0.8, sphereRadius: 0.7, smoothing: 0.25, lightX: 0, lightY: 0.3, lightZ: 0.9, ambient: 0.5, diffuse: 3.5, shadowSoft: 6, objectColor: '#00aaff', lightColor: '#88ffff', ambientColor: '#002244', bgColor: '#000308' },
                { name: 'Hawking Glow', speed: 0.4, timeOffset: 0, zoom: 1.6, fov: 1.1, camHeight: 0, spikeLength: 0.9, spikeWidth: 0.7, shellThickness: 0.45, sphereRadius: 1.1, smoothing: 0.55, lightX: 0.6, lightY: 0.7, lightZ: 0.4, ambient: 0.25, diffuse: 2.2, shadowSoft: 3, objectColor: '#ffffff', lightColor: '#aaffff', ambientColor: '#334455', bgColor: '#000208' },
                { name: 'Neon Singularity', speed: 0.7, timeOffset: 0, zoom: 1.3, fov: 1.4, camHeight: 0.2, spikeLength: 1.3, spikeWidth: 1.1, shellThickness: 0.65, sphereRadius: 0.85, smoothing: 0.35, lightX: -0.7, lightY: 0.4, lightZ: 0.5, ambient: 0.35, diffuse: 3.2, shadowSoft: 4, objectColor: '#ff00ff', lightColor: '#00ffaa', ambientColor: '#440044', bgColor: '#080005' },
                { name: 'Gold Corona', speed: 0.5, timeOffset: 0, zoom: 1.5, fov: 1.2, camHeight: 0, spikeLength: 1.0, spikeWidth: 0.85, shellThickness: 0.52, sphereRadius: 1.0, smoothing: 0.48, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.4, diffuse: 2.5, shadowSoft: 5, objectColor: '#ddaa22', lightColor: '#ffeeaa', ambientColor: '#553300', bgColor: '#0a0500' }
            ],
            18: [ // Dimensional Rift - Reality-tearing portal
                { name: 'Reality Tear', speed: 0.6, timeOffset: 0, zoom: 1.0, fov: 1.5, camHeight: 0, spikeLength: 1.5, spikeWidth: 1.0, shellThickness: 0.8, sphereRadius: 1.0, smoothing: 0.4, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.5, diffuse: 2.0, shadowSoft: 6, objectColor: '#8800ff', lightColor: '#ff00aa', ambientColor: '#220044', bgColor: '#050008' },
                { name: 'Dimension Bleed', speed: 0.8, timeOffset: 0, zoom: 0.8, fov: 1.8, camHeight: 0.3, spikeLength: 2.0, spikeWidth: 1.5, shellThickness: 1.0, sphereRadius: 0.8, smoothing: 0.3, lightX: 0.5, lightY: 0.5, lightZ: 0.5, ambient: 0.6, diffuse: 2.5, shadowSoft: 5, objectColor: '#ff0066', lightColor: '#00ffff', ambientColor: '#440022', bgColor: '#080005' },
                { name: 'Void Fracture', speed: 0.4, timeOffset: 3, zoom: 1.5, fov: 1.2, camHeight: -0.2, spikeLength: 1.0, spikeWidth: 0.7, shellThickness: 0.6, sphereRadius: 1.2, smoothing: 0.55, lightX: 0, lightY: 0.8, lightZ: 0.5, ambient: 0.25, diffuse: 1.5, shadowSoft: 3, objectColor: '#333366', lightColor: '#6666aa', ambientColor: '#111133', bgColor: '#000000' },
                { name: 'Multiverse Gate', speed: 0.7, timeOffset: 0, zoom: 1.2, fov: 1.6, camHeight: 0.1, spikeLength: 1.8, spikeWidth: 1.2, shellThickness: 0.9, sphereRadius: 0.9, smoothing: 0.35, lightX: -0.4, lightY: 0.7, lightZ: 0.5, ambient: 0.55, diffuse: 2.3, shadowSoft: 7, objectColor: '#00ff88', lightColor: '#88ffdd', ambientColor: '#003322', bgColor: '#000a05' },
                { name: 'Chaos Portal', speed: 1.0, timeOffset: 0, zoom: 0.6, fov: 2.0, camHeight: 0.4, spikeLength: 2.5, spikeWidth: 2.0, shellThickness: 1.2, sphereRadius: 0.7, smoothing: 0.2, lightX: 0.6, lightY: 0.3, lightZ: 0.7, ambient: 0.4, diffuse: 3.0, shadowSoft: 4, objectColor: '#ff4400', lightColor: '#ffaa00', ambientColor: '#551100', bgColor: '#100500' },
                { name: 'Neon Breach', speed: 0.9, timeOffset: 0, zoom: 0.9, fov: 1.7, camHeight: 0.2, spikeLength: 1.6, spikeWidth: 1.3, shellThickness: 0.85, sphereRadius: 0.85, smoothing: 0.28, lightX: -0.7, lightY: 0.4, lightZ: 0.5, ambient: 0.35, diffuse: 2.8, shadowSoft: 4, objectColor: '#ff00cc', lightColor: '#00ffbb', ambientColor: '#660044', bgColor: '#080008' },
                { name: 'Ice Dimension', speed: 0.5, timeOffset: 0, zoom: 1.3, fov: 1.4, camHeight: 0, spikeLength: 1.2, spikeWidth: 0.9, shellThickness: 0.7, sphereRadius: 1.05, smoothing: 0.45, lightX: 0.6, lightY: 0.7, lightZ: 0.4, ambient: 0.7, diffuse: 1.8, shadowSoft: 10, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#4477aa', bgColor: '#020610' },
                { name: 'Gold Anomaly', speed: 0.6, timeOffset: 0, zoom: 1.1, fov: 1.5, camHeight: 0.1, spikeLength: 1.4, spikeWidth: 1.0, shellThickness: 0.75, sphereRadius: 0.95, smoothing: 0.4, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.5, diffuse: 2.2, shadowSoft: 8, objectColor: '#ddaa44', lightColor: '#ffeecc', ambientColor: '#664411', bgColor: '#0a0500' },
                { name: 'Matrix Glitch', speed: 0.8, timeOffset: 1, zoom: 1.0, fov: 1.6, camHeight: 0.15, spikeLength: 1.7, spikeWidth: 1.15, shellThickness: 0.88, sphereRadius: 0.88, smoothing: 0.32, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.45, diffuse: 2.5, shadowSoft: 6, objectColor: '#00ff44', lightColor: '#88ff99', ambientColor: '#004411', bgColor: '#000800' }
            ],
            19: [ // Stellar Nursery - Star-forming nebula
                { name: 'Nebula Birth', speed: 0.4, timeOffset: 0, zoom: 2.0, fov: 1, camHeight: 1, spikeLength: 1.0, spikeWidth: 0.1, shellThickness: 0.3, sphereRadius: 1.5, smoothing: 0.5, lightX: 0, lightY: 1, lightZ: 0, ambient: 1.0, diffuse: 1.5, shadowSoft: 8, objectColor: '#ff6688', lightColor: '#88ddff', ambientColor: '#442266', bgColor: '#050008' },
                { name: 'Cosmic Cradle', speed: 0.3, timeOffset: 2, zoom: 2.5, fov: 1, camHeight: 1, spikeLength: 1.5, spikeWidth: 0.15, shellThickness: 0.25, sphereRadius: 1.8, smoothing: 0.6, lightX: 0.5, lightY: 0.8, lightZ: 0.3, ambient: 0.8, diffuse: 1.8, shadowSoft: 10, objectColor: '#ff88aa', lightColor: '#aaffee', ambientColor: '#330055', bgColor: '#030010' },
                { name: 'Star Forge', speed: 0.6, timeOffset: 0, zoom: 1.8, fov: 1, camHeight: 1, spikeLength: 0.8, spikeWidth: 0.08, shellThickness: 0.35, sphereRadius: 1.3, smoothing: 0.4, lightX: -0.4, lightY: 0.6, lightZ: 0.6, ambient: 0.6, diffuse: 2.2, shadowSoft: 6, objectColor: '#ffaa44', lightColor: '#ffeeaa', ambientColor: '#553311', bgColor: '#080500' },
                { name: 'Protostar', speed: 0.5, timeOffset: 0, zoom: 2.2, fov: 1, camHeight: 1, spikeLength: 1.2, spikeWidth: 0.12, shellThickness: 0.28, sphereRadius: 1.6, smoothing: 0.55, lightX: 0.3, lightY: 0.9, lightZ: 0.3, ambient: 1.2, diffuse: 1.3, shadowSoft: 12, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#446688', bgColor: '#020610' },
                { name: 'Dark Matter', speed: 0.2, timeOffset: 5, zoom: 3.0, fov: 1, camHeight: 1, spikeLength: 0.6, spikeWidth: 0.05, shellThickness: 0.4, sphereRadius: 2.0, smoothing: 0.7, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.3, diffuse: 0.6, shadowSoft: 5, objectColor: '#333355', lightColor: '#555577', ambientColor: '#1a1a33', bgColor: '#000000' },
                { name: 'Neon Nebula', speed: 0.7, timeOffset: 0, zoom: 1.5, fov: 1, camHeight: 1, spikeLength: 1.3, spikeWidth: 0.18, shellThickness: 0.32, sphereRadius: 1.2, smoothing: 0.35, lightX: -0.7, lightY: 0.4, lightZ: 0.5, ambient: 0.5, diffuse: 2.8, shadowSoft: 4, objectColor: '#ff00ff', lightColor: '#00ffcc', ambientColor: '#660066', bgColor: '#080005' },
                { name: 'Gold Dust', speed: 0.45, timeOffset: 0, zoom: 2.0, fov: 1, camHeight: 1, spikeLength: 1.0, spikeWidth: 0.1, shellThickness: 0.3, sphereRadius: 1.5, smoothing: 0.5, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.9, diffuse: 1.6, shadowSoft: 9, objectColor: '#ddaa44', lightColor: '#ffeecc', ambientColor: '#664422', bgColor: '#0a0500' },
                { name: 'Matrix Cloud', speed: 0.55, timeOffset: 1, zoom: 1.8, fov: 1, camHeight: 1, spikeLength: 1.1, spikeWidth: 0.11, shellThickness: 0.31, sphereRadius: 1.4, smoothing: 0.45, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.7, diffuse: 1.9, shadowSoft: 7, objectColor: '#00ff44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000800' },
                { name: 'Alien Birth', speed: 0.5, timeOffset: 0, zoom: 2.0, fov: 1, camHeight: 1, spikeLength: 1.0, spikeWidth: 0.1, shellThickness: 0.3, sphereRadius: 1.5, smoothing: 0.5, lightX: 0.4, lightY: 0.8, lightZ: 0.4, ambient: 1.1, diffuse: 1.4, shadowSoft: 10, objectColor: '#44ff88', lightColor: '#aaffcc', ambientColor: '#114422', bgColor: '#000a05' }
            ],
            20: [ // Cyber Grid - Infinite neon grid
                { name: 'Outrun', speed: 0.8, timeOffset: 0, zoom: 3.0, fov: 1, camHeight: 0.5, spikeLength: 0.8, spikeWidth: 0.03, shellThickness: 0.5, sphereRadius: 1, smoothing: 0.5, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.8, diffuse: 2.0, shadowSoft: 8, objectColor: '#ff00aa', lightColor: '#00ffff', ambientColor: '#440055', bgColor: '#0a0010' },
                { name: 'Synthwave', speed: 1.0, timeOffset: 0, zoom: 2.5, fov: 1, camHeight: 0.3, spikeLength: 1.0, spikeWidth: 0.04, shellThickness: 0.6, sphereRadius: 1, smoothing: 0.4, lightX: 0.5, lightY: 0.5, lightZ: 0.5, ambient: 0.6, diffuse: 2.5, shadowSoft: 6, objectColor: '#ff6600', lightColor: '#ffaa00', ambientColor: '#552200', bgColor: '#100500' },
                { name: 'Cyber Night', speed: 0.6, timeOffset: 2, zoom: 3.5, fov: 1, camHeight: 0.8, spikeLength: 0.6, spikeWidth: 0.02, shellThickness: 0.4, sphereRadius: 1, smoothing: 0.6, lightX: 0, lightY: 0.8, lightZ: 0.5, ambient: 0.5, diffuse: 1.8, shadowSoft: 10, objectColor: '#0088ff', lightColor: '#88ddff', ambientColor: '#003366', bgColor: '#000510' },
                { name: 'Neon Rush', speed: 1.2, timeOffset: 0, zoom: 2.0, fov: 1, camHeight: 0.2, spikeLength: 1.2, spikeWidth: 0.05, shellThickness: 0.7, sphereRadius: 1, smoothing: 0.3, lightX: -0.6, lightY: 0.4, lightZ: 0.6, ambient: 0.4, diffuse: 3.0, shadowSoft: 4, objectColor: '#ff00ff', lightColor: '#00ffaa', ambientColor: '#660066', bgColor: '#080005' },
                { name: 'Ice Highway', speed: 0.5, timeOffset: 0, zoom: 4.0, fov: 1, camHeight: 1.0, spikeLength: 0.5, spikeWidth: 0.02, shellThickness: 0.35, sphereRadius: 1, smoothing: 0.7, lightX: 0.6, lightY: 0.7, lightZ: 0.4, ambient: 1.0, diffuse: 1.2, shadowSoft: 12, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#5588aa', bgColor: '#020610' },
                { name: 'Void Grid', speed: 0.3, timeOffset: 4, zoom: 5.0, fov: 1, camHeight: 1.5, spikeLength: 0.4, spikeWidth: 0.015, shellThickness: 0.3, sphereRadius: 1, smoothing: 0.8, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.25, diffuse: 0.5, shadowSoft: 5, objectColor: '#333355', lightColor: '#555577', ambientColor: '#1a1a33', bgColor: '#000000' },
                { name: 'Gold Circuit', speed: 0.7, timeOffset: 0, zoom: 3.0, fov: 1, camHeight: 0.5, spikeLength: 0.8, spikeWidth: 0.03, shellThickness: 0.5, sphereRadius: 1, smoothing: 0.5, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.8, diffuse: 1.8, shadowSoft: 9, objectColor: '#ddaa44', lightColor: '#ffeecc', ambientColor: '#664422', bgColor: '#0a0500' },
                { name: 'Matrix Grid', speed: 0.9, timeOffset: 1, zoom: 2.8, fov: 1, camHeight: 0.4, spikeLength: 0.9, spikeWidth: 0.035, shellThickness: 0.55, sphereRadius: 1, smoothing: 0.45, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.6, diffuse: 2.2, shadowSoft: 7, objectColor: '#00ff44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000800' },
                { name: 'Alien Tech', speed: 0.8, timeOffset: 0, zoom: 3.0, fov: 1, camHeight: 0.5, spikeLength: 0.8, spikeWidth: 0.03, shellThickness: 0.5, sphereRadius: 1, smoothing: 0.5, lightX: 0.3, lightY: 0.9, lightZ: 0.3, ambient: 1.0, diffuse: 1.6, shadowSoft: 10, objectColor: '#44ff88', lightColor: '#aaffcc', ambientColor: '#114422', bgColor: '#000a05' }
            ],
            21: [ // Liquid Aurora - Northern lights
                { name: 'Northern Sky', speed: 0.5, timeOffset: 0, zoom: 1, fov: 1, camHeight: 0.3, spikeLength: 2.0, spikeWidth: 0.05, shellThickness: 0.5, sphereRadius: 1, smoothing: 0.8, lightX: 0, lightY: 1, lightZ: 0, ambient: 1.0, diffuse: 1.5, shadowSoft: 10, objectColor: '#44ff88', lightColor: '#88ffdd', ambientColor: '#226644', bgColor: '#000a08' },
                { name: 'Borealis', speed: 0.6, timeOffset: 0, zoom: 1, fov: 1, camHeight: 0.2, spikeLength: 2.5, spikeWidth: 0.06, shellThickness: 0.6, sphereRadius: 1, smoothing: 0.7, lightX: 0.4, lightY: 0.8, lightZ: 0.4, ambient: 0.8, diffuse: 1.8, shadowSoft: 8, objectColor: '#00ffaa', lightColor: '#aaffff', ambientColor: '#005544', bgColor: '#000805' },
                { name: 'Solar Wind', speed: 0.8, timeOffset: 0, zoom: 1, fov: 1, camHeight: 0.4, spikeLength: 1.5, spikeWidth: 0.04, shellThickness: 0.4, sphereRadius: 1, smoothing: 0.6, lightX: -0.5, lightY: 0.5, lightZ: 0.5, ambient: 0.6, diffuse: 2.2, shadowSoft: 6, objectColor: '#ff6644', lightColor: '#ffaa88', ambientColor: '#552211', bgColor: '#100500' },
                { name: 'Arctic Glow', speed: 0.4, timeOffset: 2, zoom: 1, fov: 1, camHeight: 0.5, spikeLength: 1.8, spikeWidth: 0.05, shellThickness: 0.45, sphereRadius: 1, smoothing: 0.75, lightX: 0.6, lightY: 0.7, lightZ: 0.4, ambient: 1.2, diffuse: 1.2, shadowSoft: 12, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#5588aa', bgColor: '#020610' },
                { name: 'Void Aurora', speed: 0.3, timeOffset: 4, zoom: 1, fov: 1, camHeight: 0.6, spikeLength: 1.2, spikeWidth: 0.03, shellThickness: 0.35, sphereRadius: 1, smoothing: 0.85, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.3, diffuse: 0.6, shadowSoft: 5, objectColor: '#333366', lightColor: '#666699', ambientColor: '#1a1a44', bgColor: '#000000' },
                { name: 'Neon Aurora', speed: 0.7, timeOffset: 0, zoom: 1, fov: 1, camHeight: 0.25, spikeLength: 2.2, spikeWidth: 0.055, shellThickness: 0.55, sphereRadius: 1, smoothing: 0.65, lightX: -0.7, lightY: 0.4, lightZ: 0.5, ambient: 0.5, diffuse: 2.5, shadowSoft: 4, objectColor: '#ff00dd', lightColor: '#00ffbb', ambientColor: '#660055', bgColor: '#080005' },
                { name: 'Gold Shimmer', speed: 0.5, timeOffset: 0, zoom: 1, fov: 1, camHeight: 0.3, spikeLength: 2.0, spikeWidth: 0.05, shellThickness: 0.5, sphereRadius: 1, smoothing: 0.8, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.9, diffuse: 1.6, shadowSoft: 9, objectColor: '#ddaa44', lightColor: '#ffeecc', ambientColor: '#664422', bgColor: '#0a0500' },
                { name: 'Matrix Sky', speed: 0.55, timeOffset: 1, zoom: 1, fov: 1, camHeight: 0.35, spikeLength: 1.9, spikeWidth: 0.048, shellThickness: 0.48, sphereRadius: 1, smoothing: 0.78, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.7, diffuse: 1.8, shadowSoft: 8, objectColor: '#00ff44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000800' },
                { name: 'Alien Sky', speed: 0.5, timeOffset: 0, zoom: 1, fov: 1, camHeight: 0.3, spikeLength: 2.0, spikeWidth: 0.05, shellThickness: 0.5, sphereRadius: 1, smoothing: 0.8, lightX: 0.3, lightY: 0.9, lightZ: 0.3, ambient: 1.0, diffuse: 1.5, shadowSoft: 10, objectColor: '#44ff88', lightColor: '#aaffcc', ambientColor: '#114422', bgColor: '#000a05' }
            ],
            22: [ // Fractal Flame - Fire fractals
                { name: 'Inferno', speed: 1.0, timeOffset: 0, zoom: 1.5, fov: 1, camHeight: 1, spikeLength: 1.2, spikeWidth: 0.8, shellThickness: 0.5, sphereRadius: 1.0, smoothing: 0.5, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.8, diffuse: 2.0, shadowSoft: 6, objectColor: '#ff4400', lightColor: '#ffaa44', ambientColor: '#551100', bgColor: '#100200' },
                { name: 'Phoenix', speed: 0.8, timeOffset: 0, zoom: 1.8, fov: 1, camHeight: 1, spikeLength: 1.5, spikeWidth: 1.0, shellThickness: 0.6, sphereRadius: 0.8, smoothing: 0.4, lightX: 0.5, lightY: 0.5, lightZ: 0.5, ambient: 0.6, diffuse: 2.5, shadowSoft: 5, objectColor: '#ff6622', lightColor: '#ffcc66', ambientColor: '#662200', bgColor: '#0a0200' },
                { name: 'Blue Flame', speed: 0.9, timeOffset: 0, zoom: 1.6, fov: 1, camHeight: 1, spikeLength: 1.3, spikeWidth: 0.9, shellThickness: 0.55, sphereRadius: 0.9, smoothing: 0.45, lightX: 0, lightY: 0.8, lightZ: 0.6, ambient: 0.7, diffuse: 2.2, shadowSoft: 7, objectColor: '#4488ff', lightColor: '#aaddff', ambientColor: '#112244', bgColor: '#000510' },
                { name: 'Ice Fire', speed: 0.6, timeOffset: 2, zoom: 2.0, fov: 1, camHeight: 1, spikeLength: 1.0, spikeWidth: 0.7, shellThickness: 0.45, sphereRadius: 1.1, smoothing: 0.55, lightX: 0.6, lightY: 0.7, lightZ: 0.4, ambient: 1.0, diffuse: 1.5, shadowSoft: 10, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#5588aa', bgColor: '#020610' },
                { name: 'Void Ember', speed: 0.4, timeOffset: 4, zoom: 2.5, fov: 1, camHeight: 1, spikeLength: 0.8, spikeWidth: 0.5, shellThickness: 0.35, sphereRadius: 1.3, smoothing: 0.7, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.3, diffuse: 0.8, shadowSoft: 4, objectColor: '#333344', lightColor: '#555566', ambientColor: '#1a1a33', bgColor: '#000000' },
                { name: 'Neon Blaze', speed: 1.2, timeOffset: 0, zoom: 1.3, fov: 1, camHeight: 1, spikeLength: 1.6, spikeWidth: 1.1, shellThickness: 0.65, sphereRadius: 0.7, smoothing: 0.3, lightX: -0.7, lightY: 0.4, lightZ: 0.5, ambient: 0.4, diffuse: 3.0, shadowSoft: 3, objectColor: '#ff00cc', lightColor: '#00ffaa', ambientColor: '#660055', bgColor: '#080005' },
                { name: 'Gold Flame', speed: 0.85, timeOffset: 0, zoom: 1.7, fov: 1, camHeight: 1, spikeLength: 1.25, spikeWidth: 0.85, shellThickness: 0.52, sphereRadius: 0.95, smoothing: 0.48, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.75, diffuse: 1.9, shadowSoft: 8, objectColor: '#ddaa44', lightColor: '#ffeecc', ambientColor: '#664422', bgColor: '#0a0500' },
                { name: 'Matrix Fire', speed: 0.95, timeOffset: 1, zoom: 1.55, fov: 1, camHeight: 1, spikeLength: 1.35, spikeWidth: 0.88, shellThickness: 0.53, sphereRadius: 0.92, smoothing: 0.46, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.65, diffuse: 2.1, shadowSoft: 6, objectColor: '#00ff44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000800' },
                { name: 'Alien Flame', speed: 0.9, timeOffset: 0, zoom: 1.6, fov: 1, camHeight: 1, spikeLength: 1.3, spikeWidth: 0.9, shellThickness: 0.55, sphereRadius: 0.9, smoothing: 0.45, lightX: 0.4, lightY: 0.8, lightZ: 0.4, ambient: 0.9, diffuse: 1.7, shadowSoft: 9, objectColor: '#44ff88', lightColor: '#aaffcc', ambientColor: '#114422', bgColor: '#000a05' }
            ],
            23: [ // Quantum Foam - Spacetime bubbles
                { name: 'Planck Scale', speed: 0.6, timeOffset: 0, zoom: 3.0, fov: 1, camHeight: 1, spikeLength: 2.0, spikeWidth: 0.05, shellThickness: 1.0, sphereRadius: 1.0, smoothing: 0.6, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.8, diffuse: 1.5, shadowSoft: 8, objectColor: '#8866ff', lightColor: '#aa88ff', ambientColor: '#331166', bgColor: '#050010' },
                { name: 'Virtual Particles', speed: 0.8, timeOffset: 0, zoom: 2.5, fov: 1, camHeight: 1, spikeLength: 2.5, spikeWidth: 0.06, shellThickness: 1.2, sphereRadius: 0.8, smoothing: 0.5, lightX: 0.5, lightY: 0.5, lightZ: 0.5, ambient: 0.6, diffuse: 2.0, shadowSoft: 6, objectColor: '#ff66aa', lightColor: '#ffaacc', ambientColor: '#661144', bgColor: '#100008' },
                { name: 'Spacetime Fabric', speed: 0.5, timeOffset: 2, zoom: 3.5, fov: 1, camHeight: 1, spikeLength: 1.5, spikeWidth: 0.04, shellThickness: 0.8, sphereRadius: 1.2, smoothing: 0.7, lightX: 0, lightY: 0.8, lightZ: 0.5, ambient: 1.0, diffuse: 1.2, shadowSoft: 10, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#4477aa', bgColor: '#020610' },
                { name: 'Dark Energy', speed: 0.3, timeOffset: 4, zoom: 4.0, fov: 1, camHeight: 1, spikeLength: 1.0, spikeWidth: 0.03, shellThickness: 0.6, sphereRadius: 1.5, smoothing: 0.8, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.25, diffuse: 0.6, shadowSoft: 5, objectColor: '#222244', lightColor: '#444466', ambientColor: '#111133', bgColor: '#000000' },
                { name: 'Neon Foam', speed: 0.9, timeOffset: 0, zoom: 2.2, fov: 1, camHeight: 1, spikeLength: 2.8, spikeWidth: 0.07, shellThickness: 1.4, sphereRadius: 0.7, smoothing: 0.4, lightX: -0.7, lightY: 0.4, lightZ: 0.5, ambient: 0.4, diffuse: 2.5, shadowSoft: 4, objectColor: '#ff00ee', lightColor: '#00ffaa', ambientColor: '#660066', bgColor: '#080005' },
                { name: 'Gold Quantum', speed: 0.6, timeOffset: 0, zoom: 3.0, fov: 1, camHeight: 1, spikeLength: 2.0, spikeWidth: 0.05, shellThickness: 1.0, sphereRadius: 1.0, smoothing: 0.6, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.7, diffuse: 1.6, shadowSoft: 9, objectColor: '#ddaa44', lightColor: '#ffeecc', ambientColor: '#664422', bgColor: '#0a0500' },
                { name: 'Matrix Foam', speed: 0.7, timeOffset: 1, zoom: 2.8, fov: 1, camHeight: 1, spikeLength: 2.2, spikeWidth: 0.055, shellThickness: 1.1, sphereRadius: 0.9, smoothing: 0.55, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.6, diffuse: 1.8, shadowSoft: 7, objectColor: '#00ff44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000800' },
                { name: 'Alien Foam', speed: 0.6, timeOffset: 0, zoom: 3.0, fov: 1, camHeight: 1, spikeLength: 2.0, spikeWidth: 0.05, shellThickness: 1.0, sphereRadius: 1.0, smoothing: 0.6, lightX: 0.4, lightY: 0.8, lightZ: 0.4, ambient: 0.9, diffuse: 1.4, shadowSoft: 10, objectColor: '#44ff88', lightColor: '#aaffcc', ambientColor: '#114422', bgColor: '#000a05' },
                { name: 'Fire Foam', speed: 0.7, timeOffset: 0, zoom: 2.8, fov: 1, camHeight: 1, spikeLength: 2.3, spikeWidth: 0.058, shellThickness: 1.15, sphereRadius: 0.85, smoothing: 0.52, lightX: -0.4, lightY: 0.6, lightZ: 0.6, ambient: 0.55, diffuse: 2.2, shadowSoft: 6, objectColor: '#ff4422', lightColor: '#ffaa66', ambientColor: '#551100', bgColor: '#100200' }
            ],
            24: [ // Tesseract - 4D hypercube
                { name: 'Hypercube', speed: 0.5, timeOffset: 0, zoom: 1.5, fov: 2.0, camHeight: 1, spikeLength: 1, spikeWidth: 1.0, shellThickness: 1.0, sphereRadius: 0.8, smoothing: 0.5, lightX: 0, lightY: 1, lightZ: 0, ambient: 1.0, diffuse: 1.5, shadowSoft: 10, objectColor: '#8888ff', lightColor: '#aaaaff', ambientColor: '#333388', bgColor: '#050010' },
                { name: '4D Rotation', speed: 0.7, timeOffset: 0, zoom: 1.3, fov: 2.5, camHeight: 1, spikeLength: 1, spikeWidth: 1.2, shellThickness: 1.2, sphereRadius: 0.7, smoothing: 0.4, lightX: 0.5, lightY: 0.5, lightZ: 0.5, ambient: 0.8, diffuse: 2.0, shadowSoft: 8, objectColor: '#ff88ff', lightColor: '#ffaaff', ambientColor: '#663366', bgColor: '#100010' },
                { name: 'Crystal Cube', speed: 0.4, timeOffset: 2, zoom: 1.8, fov: 1.8, camHeight: 1, spikeLength: 1, spikeWidth: 0.8, shellThickness: 0.8, sphereRadius: 0.9, smoothing: 0.6, lightX: 0.6, lightY: 0.7, lightZ: 0.4, ambient: 1.2, diffuse: 1.2, shadowSoft: 12, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#5588aa', bgColor: '#020610' },
                { name: 'Void Cube', speed: 0.3, timeOffset: 4, zoom: 2.0, fov: 1.5, camHeight: 1, spikeLength: 1, spikeWidth: 0.6, shellThickness: 0.6, sphereRadius: 1.0, smoothing: 0.7, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.3, diffuse: 0.6, shadowSoft: 6, objectColor: '#333355', lightColor: '#555577', ambientColor: '#1a1a33', bgColor: '#000000' },
                { name: 'Neon Cube', speed: 0.8, timeOffset: 0, zoom: 1.2, fov: 2.8, camHeight: 1, spikeLength: 1, spikeWidth: 1.4, shellThickness: 1.4, sphereRadius: 0.6, smoothing: 0.3, lightX: -0.7, lightY: 0.4, lightZ: 0.5, ambient: 0.5, diffuse: 2.5, shadowSoft: 5, objectColor: '#ff00ff', lightColor: '#00ffff', ambientColor: '#660066', bgColor: '#080005' },
                { name: 'Gold Cube', speed: 0.5, timeOffset: 0, zoom: 1.5, fov: 2.0, camHeight: 1, spikeLength: 1, spikeWidth: 1.0, shellThickness: 1.0, sphereRadius: 0.8, smoothing: 0.5, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.9, diffuse: 1.6, shadowSoft: 9, objectColor: '#ddaa44', lightColor: '#ffeecc', ambientColor: '#664422', bgColor: '#0a0500' },
                { name: 'Matrix Cube', speed: 0.6, timeOffset: 1, zoom: 1.4, fov: 2.2, camHeight: 1, spikeLength: 1, spikeWidth: 1.1, shellThickness: 1.1, sphereRadius: 0.75, smoothing: 0.45, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.7, diffuse: 1.8, shadowSoft: 8, objectColor: '#00ff44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000800' },
                { name: 'Alien Cube', speed: 0.5, timeOffset: 0, zoom: 1.5, fov: 2.0, camHeight: 1, spikeLength: 1, spikeWidth: 1.0, shellThickness: 1.0, sphereRadius: 0.8, smoothing: 0.5, lightX: 0.4, lightY: 0.8, lightZ: 0.4, ambient: 1.0, diffuse: 1.5, shadowSoft: 10, objectColor: '#44ff88', lightColor: '#aaffcc', ambientColor: '#114422', bgColor: '#000a05' },
                { name: 'Fire Cube', speed: 0.65, timeOffset: 0, zoom: 1.4, fov: 2.3, camHeight: 1, spikeLength: 1, spikeWidth: 1.15, shellThickness: 1.15, sphereRadius: 0.72, smoothing: 0.42, lightX: -0.5, lightY: 0.5, lightZ: 0.6, ambient: 0.6, diffuse: 2.2, shadowSoft: 6, objectColor: '#ff4422', lightColor: '#ffaa66', ambientColor: '#551100', bgColor: '#100200' }
            ],
            25: [ // Digital Rain - Matrix rain
                { name: 'Matrix', speed: 1.0, timeOffset: 0, zoom: 1, fov: 1, camHeight: 1, spikeLength: 1.0, spikeWidth: 0.05, shellThickness: 1.0, sphereRadius: 0.8, smoothing: 0.5, lightX: 0, lightY: 1, lightZ: 0, ambient: 1.0, diffuse: 1.5, shadowSoft: 10, objectColor: '#00ff44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000800' },
                { name: 'Red Pill', speed: 1.2, timeOffset: 0, zoom: 1, fov: 1, camHeight: 1, spikeLength: 1.2, spikeWidth: 0.06, shellThickness: 1.2, sphereRadius: 0.7, smoothing: 0.4, lightX: 0.5, lightY: 0.5, lightZ: 0.5, ambient: 0.8, diffuse: 2.0, shadowSoft: 8, objectColor: '#ff4444', lightColor: '#ff8888', ambientColor: '#441111', bgColor: '#100000' },
                { name: 'Blue Code', speed: 0.8, timeOffset: 2, zoom: 1, fov: 1, camHeight: 1, spikeLength: 0.8, spikeWidth: 0.04, shellThickness: 0.8, sphereRadius: 0.9, smoothing: 0.6, lightX: 0, lightY: 0.8, lightZ: 0.5, ambient: 1.0, diffuse: 1.5, shadowSoft: 10, objectColor: '#4488ff', lightColor: '#88aaff', ambientColor: '#112244', bgColor: '#000510' },
                { name: 'Ice Code', speed: 0.6, timeOffset: 0, zoom: 1, fov: 1, camHeight: 1, spikeLength: 0.7, spikeWidth: 0.035, shellThickness: 0.7, sphereRadius: 1.0, smoothing: 0.7, lightX: 0.6, lightY: 0.7, lightZ: 0.4, ambient: 1.2, diffuse: 1.2, shadowSoft: 12, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#5588aa', bgColor: '#020610' },
                { name: 'Void Code', speed: 0.4, timeOffset: 4, zoom: 1, fov: 1, camHeight: 1, spikeLength: 0.5, spikeWidth: 0.025, shellThickness: 0.5, sphereRadius: 1.2, smoothing: 0.8, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.3, diffuse: 0.6, shadowSoft: 6, objectColor: '#333355', lightColor: '#555577', ambientColor: '#1a1a33', bgColor: '#000000' },
                { name: 'Neon Rain', speed: 1.5, timeOffset: 0, zoom: 1, fov: 1, camHeight: 1, spikeLength: 1.5, spikeWidth: 0.08, shellThickness: 1.5, sphereRadius: 0.6, smoothing: 0.3, lightX: -0.7, lightY: 0.4, lightZ: 0.5, ambient: 0.5, diffuse: 2.5, shadowSoft: 5, objectColor: '#ff00ff', lightColor: '#00ffff', ambientColor: '#660066', bgColor: '#080008' },
                { name: 'Gold Rain', speed: 0.9, timeOffset: 0, zoom: 1, fov: 1, camHeight: 1, spikeLength: 0.9, spikeWidth: 0.045, shellThickness: 0.9, sphereRadius: 0.85, smoothing: 0.55, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.9, diffuse: 1.6, shadowSoft: 9, objectColor: '#ddaa44', lightColor: '#ffeecc', ambientColor: '#664422', bgColor: '#0a0500' },
                { name: 'Alien Data', speed: 1.0, timeOffset: 0, zoom: 1, fov: 1, camHeight: 1, spikeLength: 1.0, spikeWidth: 0.05, shellThickness: 1.0, sphereRadius: 0.8, smoothing: 0.5, lightX: 0.4, lightY: 0.8, lightZ: 0.4, ambient: 1.0, diffuse: 1.5, shadowSoft: 10, objectColor: '#44ff88', lightColor: '#aaffcc', ambientColor: '#114422', bgColor: '#000a05' },
                { name: 'Fire Data', speed: 1.1, timeOffset: 0, zoom: 1, fov: 1, camHeight: 1, spikeLength: 1.1, spikeWidth: 0.055, shellThickness: 1.1, sphereRadius: 0.75, smoothing: 0.45, lightX: -0.5, lightY: 0.5, lightZ: 0.6, ambient: 0.7, diffuse: 2.0, shadowSoft: 6, objectColor: '#ff4422', lightColor: '#ffaa66', ambientColor: '#551100', bgColor: '#100200' }
            ],
            26: [ // Nebula Core - Explosive nebula
                { name: 'Supernova', speed: 0.6, timeOffset: 0, zoom: 2.0, fov: 1, camHeight: 1, spikeLength: 1.5, spikeWidth: 0.05, shellThickness: 0.4, sphereRadius: 1.2, smoothing: 0.8, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.8, diffuse: 2.0, shadowSoft: 8, objectColor: '#ff6644', lightColor: '#ffaa88', ambientColor: '#552211', bgColor: '#100500' },
                { name: 'Starburst', speed: 0.8, timeOffset: 0, zoom: 1.8, fov: 1, camHeight: 1, spikeLength: 1.8, spikeWidth: 0.06, shellThickness: 0.5, sphereRadius: 1.0, smoothing: 0.7, lightX: 0.5, lightY: 0.5, lightZ: 0.5, ambient: 0.6, diffuse: 2.5, shadowSoft: 6, objectColor: '#ffaa44', lightColor: '#ffddaa', ambientColor: '#664411', bgColor: '#0a0500' },
                { name: 'Blue Giant', speed: 0.5, timeOffset: 2, zoom: 2.2, fov: 1, camHeight: 1, spikeLength: 1.2, spikeWidth: 0.04, shellThickness: 0.35, sphereRadius: 1.3, smoothing: 0.85, lightX: 0, lightY: 0.8, lightZ: 0.5, ambient: 1.0, diffuse: 1.5, shadowSoft: 10, objectColor: '#4488ff', lightColor: '#aaddff', ambientColor: '#112244', bgColor: '#000510' },
                { name: 'Ice Nova', speed: 0.4, timeOffset: 0, zoom: 2.5, fov: 1, camHeight: 1, spikeLength: 1.0, spikeWidth: 0.03, shellThickness: 0.3, sphereRadius: 1.4, smoothing: 0.9, lightX: 0.6, lightY: 0.7, lightZ: 0.4, ambient: 1.2, diffuse: 1.2, shadowSoft: 12, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#5588aa', bgColor: '#020610' },
                { name: 'Dark Nova', speed: 0.3, timeOffset: 4, zoom: 3.0, fov: 1, camHeight: 1, spikeLength: 0.8, spikeWidth: 0.02, shellThickness: 0.25, sphereRadius: 1.6, smoothing: 0.95, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.3, diffuse: 0.6, shadowSoft: 5, objectColor: '#333355', lightColor: '#555577', ambientColor: '#1a1a33', bgColor: '#000000' },
                { name: 'Neon Nova', speed: 0.9, timeOffset: 0, zoom: 1.5, fov: 1, camHeight: 1, spikeLength: 2.0, spikeWidth: 0.07, shellThickness: 0.55, sphereRadius: 0.9, smoothing: 0.6, lightX: -0.7, lightY: 0.4, lightZ: 0.5, ambient: 0.5, diffuse: 2.8, shadowSoft: 4, objectColor: '#ff00ff', lightColor: '#00ffdd', ambientColor: '#660066', bgColor: '#080005' },
                { name: 'Gold Nova', speed: 0.6, timeOffset: 0, zoom: 2.0, fov: 1, camHeight: 1, spikeLength: 1.5, spikeWidth: 0.05, shellThickness: 0.4, sphereRadius: 1.2, smoothing: 0.8, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.9, diffuse: 1.8, shadowSoft: 9, objectColor: '#ddaa44', lightColor: '#ffeecc', ambientColor: '#664422', bgColor: '#0a0500' },
                { name: 'Matrix Nova', speed: 0.7, timeOffset: 1, zoom: 1.9, fov: 1, camHeight: 1, spikeLength: 1.6, spikeWidth: 0.055, shellThickness: 0.45, sphereRadius: 1.1, smoothing: 0.75, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.7, diffuse: 2.0, shadowSoft: 8, objectColor: '#00ff44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000800' },
                { name: 'Alien Nova', speed: 0.6, timeOffset: 0, zoom: 2.0, fov: 1, camHeight: 1, spikeLength: 1.5, spikeWidth: 0.05, shellThickness: 0.4, sphereRadius: 1.2, smoothing: 0.8, lightX: 0.4, lightY: 0.8, lightZ: 0.4, ambient: 1.0, diffuse: 1.6, shadowSoft: 10, objectColor: '#44ff88', lightColor: '#aaffcc', ambientColor: '#114422', bgColor: '#000a05' }
            ],
            27: [ // Crystal Cavern - Crystalline formations
                { name: 'Amethyst', speed: 0.5, timeOffset: 0, zoom: 2.5, fov: 1, camHeight: 1, spikeLength: 2.0, spikeWidth: 0.15, shellThickness: 1.5, sphereRadius: 1.0, smoothing: 0.6, lightX: 0, lightY: 1, lightZ: 0, ambient: 1.0, diffuse: 1.5, shadowSoft: 10, objectColor: '#aa66ff', lightColor: '#ddaaff', ambientColor: '#442266', bgColor: '#0a0015' },
                { name: 'Emerald', speed: 0.6, timeOffset: 0, zoom: 2.2, fov: 1, camHeight: 1, spikeLength: 2.5, spikeWidth: 0.18, shellThickness: 1.8, sphereRadius: 0.9, smoothing: 0.5, lightX: 0.5, lightY: 0.5, lightZ: 0.5, ambient: 0.8, diffuse: 1.8, shadowSoft: 8, objectColor: '#44ff88', lightColor: '#aaffcc', ambientColor: '#114422', bgColor: '#000a05' },
                { name: 'Ruby', speed: 0.7, timeOffset: 0, zoom: 2.0, fov: 1, camHeight: 1, spikeLength: 2.2, spikeWidth: 0.16, shellThickness: 1.6, sphereRadius: 0.95, smoothing: 0.55, lightX: -0.4, lightY: 0.6, lightZ: 0.6, ambient: 0.7, diffuse: 2.0, shadowSoft: 7, objectColor: '#ff4466', lightColor: '#ffaacc', ambientColor: '#551133', bgColor: '#100008' },
                { name: 'Diamond', speed: 0.4, timeOffset: 2, zoom: 3.0, fov: 1, camHeight: 1, spikeLength: 1.5, spikeWidth: 0.12, shellThickness: 1.2, sphereRadius: 1.1, smoothing: 0.7, lightX: 0.6, lightY: 0.7, lightZ: 0.4, ambient: 1.4, diffuse: 1.2, shadowSoft: 14, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#5588aa', bgColor: '#020610' },
                { name: 'Obsidian', speed: 0.3, timeOffset: 4, zoom: 3.5, fov: 1, camHeight: 1, spikeLength: 1.2, spikeWidth: 0.1, shellThickness: 1.0, sphereRadius: 1.2, smoothing: 0.8, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.3, diffuse: 0.6, shadowSoft: 5, objectColor: '#222244', lightColor: '#444466', ambientColor: '#111133', bgColor: '#000000' },
                { name: 'Neon Crystal', speed: 0.8, timeOffset: 0, zoom: 1.8, fov: 1, camHeight: 1, spikeLength: 2.8, spikeWidth: 0.2, shellThickness: 2.0, sphereRadius: 0.8, smoothing: 0.4, lightX: -0.7, lightY: 0.4, lightZ: 0.5, ambient: 0.5, diffuse: 2.5, shadowSoft: 4, objectColor: '#ff00ff', lightColor: '#00ffcc', ambientColor: '#660066', bgColor: '#080005' },
                { name: 'Gold Crystal', speed: 0.5, timeOffset: 0, zoom: 2.5, fov: 1, camHeight: 1, spikeLength: 2.0, spikeWidth: 0.15, shellThickness: 1.5, sphereRadius: 1.0, smoothing: 0.6, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.9, diffuse: 1.6, shadowSoft: 9, objectColor: '#ddaa44', lightColor: '#ffeecc', ambientColor: '#664422', bgColor: '#0a0500' },
                { name: 'Matrix Crystal', speed: 0.55, timeOffset: 1, zoom: 2.3, fov: 1, camHeight: 1, spikeLength: 2.1, spikeWidth: 0.155, shellThickness: 1.55, sphereRadius: 0.98, smoothing: 0.58, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.75, diffuse: 1.7, shadowSoft: 8, objectColor: '#00ff44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000800' },
                { name: 'Sapphire', speed: 0.5, timeOffset: 0, zoom: 2.5, fov: 1, camHeight: 1, spikeLength: 2.0, spikeWidth: 0.15, shellThickness: 1.5, sphereRadius: 1.0, smoothing: 0.6, lightX: 0, lightY: 0.8, lightZ: 0.5, ambient: 1.0, diffuse: 1.5, shadowSoft: 10, objectColor: '#4488ff', lightColor: '#aaddff', ambientColor: '#112244', bgColor: '#000510' }
            ],
            28: [ // Infinity Mirror - Recursive reflections
                { name: 'Endless Hall', speed: 0.4, timeOffset: 0, zoom: 1.5, fov: 1, camHeight: 0.5, spikeLength: 1.5, spikeWidth: 0.8, shellThickness: 0.25, sphereRadius: 0.7, smoothing: 0.6, lightX: 0, lightY: 1, lightZ: 0, ambient: 1.0, diffuse: 1.5, shadowSoft: 12, objectColor: '#8888ff', lightColor: '#aaaaff', ambientColor: '#333388', bgColor: '#050010' },
                { name: 'Neon Tunnel', speed: 0.6, timeOffset: 0, zoom: 1.3, fov: 1, camHeight: 0.3, spikeLength: 1.8, spikeWidth: 1.0, shellThickness: 0.3, sphereRadius: 0.6, smoothing: 0.5, lightX: 0.5, lightY: 0.5, lightZ: 0.5, ambient: 0.8, diffuse: 2.0, shadowSoft: 10, objectColor: '#ff00aa', lightColor: '#00ffff', ambientColor: '#660055', bgColor: '#0a0010' },
                { name: 'Crystal Hall', speed: 0.35, timeOffset: 2, zoom: 1.8, fov: 1, camHeight: 0.7, spikeLength: 1.2, spikeWidth: 0.6, shellThickness: 0.2, sphereRadius: 0.8, smoothing: 0.7, lightX: 0.6, lightY: 0.7, lightZ: 0.4, ambient: 1.3, diffuse: 1.2, shadowSoft: 14, objectColor: '#aaddff', lightColor: '#ffffff', ambientColor: '#5588aa', bgColor: '#020610' },
                { name: 'Void Mirror', speed: 0.25, timeOffset: 4, zoom: 2.0, fov: 1, camHeight: 0.9, spikeLength: 1.0, spikeWidth: 0.5, shellThickness: 0.15, sphereRadius: 0.9, smoothing: 0.8, lightX: 0, lightY: 1, lightZ: 0, ambient: 0.3, diffuse: 0.5, shadowSoft: 6, objectColor: '#333355', lightColor: '#555577', ambientColor: '#1a1a33', bgColor: '#000000' },
                { name: 'Fire Mirror', speed: 0.5, timeOffset: 0, zoom: 1.4, fov: 1, camHeight: 0.4, spikeLength: 1.6, spikeWidth: 0.9, shellThickness: 0.28, sphereRadius: 0.65, smoothing: 0.55, lightX: -0.5, lightY: 0.5, lightZ: 0.6, ambient: 0.6, diffuse: 2.2, shadowSoft: 8, objectColor: '#ff4422', lightColor: '#ffaa66', ambientColor: '#551100', bgColor: '#100200' },
                { name: 'Neon Infinity', speed: 0.7, timeOffset: 0, zoom: 1.2, fov: 1, camHeight: 0.2, spikeLength: 2.0, spikeWidth: 1.2, shellThickness: 0.35, sphereRadius: 0.55, smoothing: 0.4, lightX: -0.7, lightY: 0.4, lightZ: 0.5, ambient: 0.5, diffuse: 2.5, shadowSoft: 5, objectColor: '#ff00ff', lightColor: '#00ffcc', ambientColor: '#660066', bgColor: '#080005' },
                { name: 'Gold Mirror', speed: 0.4, timeOffset: 0, zoom: 1.5, fov: 1, camHeight: 0.5, spikeLength: 1.5, spikeWidth: 0.8, shellThickness: 0.25, sphereRadius: 0.7, smoothing: 0.6, lightX: -0.5, lightY: 0.7, lightZ: 0.5, ambient: 0.9, diffuse: 1.6, shadowSoft: 10, objectColor: '#ddaa44', lightColor: '#ffeecc', ambientColor: '#664422', bgColor: '#0a0500' },
                { name: 'Matrix Mirror', speed: 0.45, timeOffset: 1, zoom: 1.45, fov: 1, camHeight: 0.45, spikeLength: 1.55, spikeWidth: 0.85, shellThickness: 0.26, sphereRadius: 0.68, smoothing: 0.58, lightX: -0.3, lightY: 0.85, lightZ: 0.45, ambient: 0.75, diffuse: 1.7, shadowSoft: 9, objectColor: '#00ff44', lightColor: '#88ff99', ambientColor: '#003311', bgColor: '#000800' },
                { name: 'Alien Mirror', speed: 0.4, timeOffset: 0, zoom: 1.5, fov: 1, camHeight: 0.5, spikeLength: 1.5, spikeWidth: 0.8, shellThickness: 0.25, sphereRadius: 0.7, smoothing: 0.6, lightX: 0.4, lightY: 0.8, lightZ: 0.4, ambient: 1.0, diffuse: 1.5, shadowSoft: 11, objectColor: '#44ff88', lightColor: '#aaffcc', ambientColor: '#114422', bgColor: '#000a05' }
            ]
        };

        const shaderNames = ['Fractal Orb', 'Plasma Sphere', 'Icosahedron Spikes', 'Crystal Matrix', 'Neon Wireframe', 'Cyberpunk City', 'Liquid Metal', 'Quantum Flux', 'Void Tendrils', 'Prismatic Storm', 'Biomech Entity', 'Fractal Cosmos', 'Plasma Vortex', 'Neon Boxes', 'Warp Tunnel', 'Hyperdrive', 'Neural Storm', 'Cosmic Singularity', 'Dimensional Rift', 'Stellar Nursery', 'Cyber Grid', 'Liquid Aurora', 'Fractal Flame', 'Quantum Foam', 'Tesseract', 'Digital Rain', 'Nebula Core', 'Crystal Cavern', 'Infinity Mirror'];

        // ============================================
        // WEBGL SETUP
        // ============================================

        let currentShader = 0;
        let currentPreset = 0;
        let program = null;
        let paused = false;
        let time = 0;
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 60;
        let mouseX = 0, mouseY = 0, mouseDown = 0;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexSource, fragmentSource) {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);

            if (!vertexShader || !fragmentShader) return null;

            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }

        function initWebGL() {
            resizeCanvas();

            // Create fullscreen quad
            const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            switchShader(0);
        }

        function switchShader(index) {
            currentShader = index;
            const shaderSources = [
                shaders.fractalOrb,
                shaders.plasmaSphere,
                shaders.icosahedron,
                shaders.crystalMatrix,
                shaders.neonWireframe,
                shaders.cyberpunkCity,
                shaders.liquidMetal,
                shaders.quantumFlux,
                shaders.voidTendrils,
                shaders.prismaticStorm,
                shaders.biomechEntity,
                shaders.fractalCosmos,
                shaders.plasmaVortex,
                shaders.neonBoxes,
                shaders.warpTunnel,
                shaders.hyperdrive,
                shaders.neuralStorm,
                shaders.cosmicSingularity,
                shaders.dimensionalRift,
                shaders.stellarNursery,
                shaders.cyberGrid,
                shaders.liquidAurora,
                shaders.fractalFlame,
                shaders.quantumFoam,
                shaders.tesseract,
                shaders.digitalRain,
                shaders.nebulaCore,
                shaders.crystalCavern,
                shaders.infinityMirror
            ];

            if (program) gl.deleteProgram(program);
            program = createProgram(gl, vertexShaderSource, shaderSources[index]);

            if (program) {
                gl.useProgram(program);
                const posLoc = gl.getAttribLocation(program, 'a_position');
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
            }

            updatePresetIndicator();
        }

        // ============================================
        // UI FUNCTIONS
        // ============================================

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16) / 255,
                g: parseInt(result[2], 16) / 255,
                b: parseInt(result[3], 16) / 255
            } : { r: 0.5, g: 0.5, b: 0.5 };
        }

        function getSliderValue(id) {
            return parseFloat(document.getElementById(id).value);
        }

        function getColorValue(id) {
            return hexToRgb(document.getElementById(id).value);
        }

        function updateSlider(id, value, min, max) {
            const slider = document.getElementById(id);
            const valueDisplay = document.getElementById(id + 'Value');
            const fill = document.getElementById(id + 'Fill');

            slider.value = value;
            valueDisplay.textContent = value.toFixed(2);
            const percent = ((value - min) / (max - min)) * 100;
            fill.style.width = percent + '%';
        }

        function updateColor(id, value) {
            document.getElementById(id).value = value;
            document.getElementById(id + 'Hex').textContent = value.toUpperCase();
        }

        function applyPreset(presetIndex) {
            currentPreset = presetIndex;
            const preset = presets[currentShader][presetIndex];

            // Update sliders
            updateSlider('speed', preset.speed, 0, 3);
            updateSlider('timeOffset', preset.timeOffset, 0, 10);
            updateSlider('zoom', preset.zoom, 1, 10);
            updateSlider('fov', preset.fov, 0.5, 5);
            updateSlider('camHeight', preset.camHeight, 0, 2);
            updateSlider('spikeLength', preset.spikeLength, 0, 3);
            updateSlider('spikeWidth', preset.spikeWidth, 0.01, 0.3);
            updateSlider('shellThickness', preset.shellThickness, 0.01, 0.2);
            updateSlider('sphereRadius', preset.sphereRadius, 0.5, 2);
            updateSlider('smoothing', preset.smoothing, 0, 0.5);
            updateSlider('lightX', preset.lightX, -1, 1);
            updateSlider('lightY', preset.lightY, -1, 1);
            updateSlider('lightZ', preset.lightZ, -1, 1);
            updateSlider('ambient', preset.ambient, 0, 2);
            updateSlider('diffuse', preset.diffuse, 0, 3);
            updateSlider('shadowSoft', preset.shadowSoft, 1, 20);

            // Update colors
            updateColor('objectColor', preset.objectColor);
            updateColor('lightColor', preset.lightColor);
            updateColor('ambientColor', preset.ambientColor);
            updateColor('bgColor', preset.bgColor);

            // Update preset buttons
            document.querySelectorAll('.preset-btn').forEach((btn, i) => {
                btn.classList.toggle('active', i === presetIndex);
            });

            updatePresetIndicator();
        }

        function updatePresetIndicator() {
            const indicator = document.getElementById('presetIndicator');
            indicator.textContent = `${shaderNames[currentShader]} | ${presets[currentShader][currentPreset].name}`;
        }

        // All presets now enabled for all shaders
        function updatePresetButtonStates() {
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.classList.remove('disabled');
            });
        }

        function setupSliderListeners() {
            const sliders = [
                'speed', 'timeOffset', 'zoom', 'fov', 'camHeight',
                'spikeLength', 'spikeWidth', 'shellThickness', 'sphereRadius', 'smoothing',
                'lightX', 'lightY', 'lightZ', 'ambient', 'diffuse', 'shadowSoft'
            ];

            sliders.forEach(id => {
                const slider = document.getElementById(id);
                slider.addEventListener('input', () => {
                    const value = parseFloat(slider.value);
                    document.getElementById(id + 'Value').textContent = value.toFixed(2);
                    const min = parseFloat(slider.min);
                    const max = parseFloat(slider.max);
                    const percent = ((value - min) / (max - min)) * 100;
                    document.getElementById(id + 'Fill').style.width = percent + '%';
                });
            });

            // Color pickers
            ['objectColor', 'lightColor', 'ambientColor', 'bgColor'].forEach(id => {
                document.getElementById(id).addEventListener('input', (e) => {
                    document.getElementById(id + 'Hex').textContent = e.target.value.toUpperCase();
                });
            });
        }

        function setupEventListeners() {
            // Shader selector
            document.getElementById('shaderSelect').addEventListener('change', (e) => {
                switchShader(parseInt(e.target.value));
                updatePresetButtonStates();
                applyPreset(0);
            });

            // Preset buttons
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    applyPreset(parseInt(btn.dataset.preset));
                });
            });

            // Pause toggle
            document.getElementById('pauseToggle').addEventListener('click', function() {
                paused = !paused;
                this.classList.toggle('active', paused);
            });

            // Reset button
            document.getElementById('resetBtn').addEventListener('click', () => {
                applyPreset(currentPreset);
            });

            // Export button
            document.getElementById('exportBtn').addEventListener('click', () => {
                exportShader();
            });

            // Random button
            document.getElementById('randomBtn').addEventListener('click', randomize);

            // Screenshot button
            document.getElementById('screenshotBtn').addEventListener('click', takeScreenshot);

            // Modal
            document.getElementById('modalClose').addEventListener('click', () => {
                document.getElementById('exportModal').classList.remove('active');
            });

            document.getElementById('copyBtn').addEventListener('click', () => {
                navigator.clipboard.writeText(document.getElementById('exportCode').textContent);
                document.getElementById('copyBtn').textContent = 'Copied!';
                setTimeout(() => {
                    document.getElementById('copyBtn').textContent = 'Copy to Clipboard';
                }, 2000);
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space') {
                    e.preventDefault();
                    paused = !paused;
                    document.getElementById('pauseToggle').classList.toggle('active', paused);
                } else if (e.code === 'KeyR') {
                    applyPreset(currentPreset);
                } else if (e.code === 'KeyS') {
                    takeScreenshot();
                }
            });

            // Mouse events
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = rect.height - (e.clientY - rect.top);
            });

            canvas.addEventListener('mousedown', () => mouseDown = 1);
            canvas.addEventListener('mouseup', () => mouseDown = 0);

            // Resize
            window.addEventListener('resize', resizeCanvas);

            // Audio control setup
            const bgAudio = document.getElementById('bgAudio');
            const audioControl = document.getElementById('audioControl');

            // Set initial volume to 40% and muted
            bgAudio.volume = 0.4;
            bgAudio.muted = true;

            // Start playing (will be muted initially)
            bgAudio.play().catch(e => console.log('Audio autoplay blocked:', e));

            audioControl.addEventListener('click', function() {
                if (bgAudio.muted) {
                    bgAudio.muted = false;
                    bgAudio.play().catch(e => console.log('Audio play error:', e));
                    audioControl.textContent = 'PLAYING';
                    audioControl.classList.add('playing');
                    audioControl.title = 'Click to mute audio';
                } else {
                    bgAudio.muted = true;
                    audioControl.textContent = 'MUTED';
                    audioControl.classList.remove('playing');
                    audioControl.title = 'Click to unmute audio';
                }
            });
        }

        function randomize() {
            const randRange = (min, max) => Math.random() * (max - min) + min;
            const randColor = () => '#' + Math.floor(Math.random() * 16777215).toString(16).padStart(6, '0');

            updateSlider('speed', randRange(0.1, 2), 0, 3);
            updateSlider('timeOffset', randRange(0, 5), 0, 10);
            updateSlider('zoom', randRange(2, 6), 1, 10);
            updateSlider('fov', randRange(1, 3), 0.5, 5);
            updateSlider('camHeight', randRange(0.5, 1.5), 0, 2);
            updateSlider('spikeLength', randRange(0.5, 2), 0, 3);
            updateSlider('spikeWidth', randRange(0.02, 0.15), 0.01, 0.3);
            updateSlider('shellThickness', randRange(0.01, 0.1), 0.01, 0.2);
            updateSlider('sphereRadius', randRange(0.7, 1.5), 0.5, 2);
            updateSlider('smoothing', randRange(0.05, 0.25), 0, 0.5);
            updateSlider('lightX', randRange(-1, 1), -1, 1);
            updateSlider('lightY', randRange(0, 1), -1, 1);
            updateSlider('lightZ', randRange(-1, 1), -1, 1);
            updateSlider('ambient', randRange(0.3, 1.5), 0, 2);
            updateSlider('diffuse', randRange(0.5, 2), 0, 3);
            updateSlider('shadowSoft', randRange(3, 15), 1, 20);

            updateColor('objectColor', randColor());
            updateColor('lightColor', randColor());
            updateColor('ambientColor', randColor());
            updateColor('bgColor', '#' + Math.floor(Math.random() * 1118481).toString(16).padStart(6, '0')); // Darker bg
        }

        function takeScreenshot() {
            const link = document.createElement('a');
            link.download = `shader-lab-${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        function exportShader() {
            // Get the current shader source
            const shaderSources = [
                shaders.fractalOrb,
                shaders.plasmaSphere,
                shaders.icosahedron,
                shaders.crystalMatrix,
                shaders.neonWireframe,
                shaders.cyberpunkCity,
                shaders.liquidMetal,
                shaders.quantumFlux,
                shaders.voidTendrils,
                shaders.prismaticStorm,
                shaders.biomechEntity,
                shaders.fractalCosmos,
                shaders.plasmaVortex,
                shaders.neonBoxes,
                shaders.warpTunnel,
                shaders.hyperdrive,
                shaders.neuralStorm,
                shaders.cosmicSingularity,
                shaders.dimensionalRift,
                shaders.stellarNursery,
                shaders.cyberGrid,
                shaders.liquidAurora,
                shaders.fractalFlame,
                shaders.quantumFoam,
                shaders.tesseract,
                shaders.digitalRain,
                shaders.nebulaCore,
                shaders.crystalCavern,
                shaders.infinityMirror
            ];

            let shaderCode = shaderSources[currentShader];

            // Remove WebGL-specific lines and convert to Shadertoy format
            shaderCode = shaderCode
                // Remove precision declaration (Shadertoy handles this)
                .replace(/precision highp float;\s*/g, '')
                // Remove uniform declarations - we'll use defines instead
                .replace(/uniform vec2 iResolution;\s*/g, '')
                .replace(/uniform float iTime;\s*/g, '')
                .replace(/uniform vec4 iMouse;\s*/g, '')
                .replace(/uniform float uSpeed;\s*/g, '')
                .replace(/uniform float uTimeOffset;\s*/g, '')
                .replace(/uniform float uZoom;\s*/g, '')
                .replace(/uniform float uFov;\s*/g, '')
                .replace(/uniform float uCamHeight;\s*/g, '')
                .replace(/uniform float uSpikeLength;\s*/g, '')
                .replace(/uniform float uSpikeWidth;\s*/g, '')
                .replace(/uniform float uShellThickness;\s*/g, '')
                .replace(/uniform float uSphereRadius;\s*/g, '')
                .replace(/uniform float uSmoothing;\s*/g, '')
                .replace(/uniform vec3 uLightDir;\s*/g, '')
                .replace(/uniform float uAmbient;\s*/g, '')
                .replace(/uniform float uDiffuse;\s*/g, '')
                .replace(/uniform float uShadowSoft;\s*/g, '')
                .replace(/uniform vec3 uObjectColor;\s*/g, '')
                .replace(/uniform vec3 uLightColor;\s*/g, '')
                .replace(/uniform vec3 uAmbientColor;\s*/g, '')
                .replace(/uniform vec3 uBgColor;\s*/g, '')
                // Convert main() to mainImage()
                .replace(/void main\(\)\s*\{/, 'void mainImage(out vec4 fragColor, in vec2 fragCoord) {')
                // Replace gl_FragCoord with fragCoord
                .replace(/gl_FragCoord/g, 'fragCoord')
                // Replace gl_FragColor with fragColor
                .replace(/gl_FragColor/g, 'fragColor')
                .trim();

            // Build the defines header with current parameter values
            const defines = `// ============================================
// Shader Lab Pro+ Export - Shadertoy Compatible
// ${shaderNames[currentShader]} - ${presets[currentShader][currentPreset].name}
// ============================================

// Parameter Defines (edit these to change the look)
#define uSpeed ${getSliderValue('speed').toFixed(3)}
#define uTimeOffset ${getSliderValue('timeOffset').toFixed(3)}
#define uZoom ${getSliderValue('zoom').toFixed(3)}
#define uFov ${getSliderValue('fov').toFixed(3)}
#define uCamHeight ${getSliderValue('camHeight').toFixed(3)}
#define uSpikeLength ${getSliderValue('spikeLength').toFixed(3)}
#define uSpikeWidth ${getSliderValue('spikeWidth').toFixed(3)}
#define uShellThickness ${getSliderValue('shellThickness').toFixed(3)}
#define uSphereRadius ${getSliderValue('sphereRadius').toFixed(3)}
#define uSmoothing ${getSliderValue('smoothing').toFixed(3)}
#define uLightDir vec3(${getSliderValue('lightX').toFixed(3)}, ${getSliderValue('lightY').toFixed(3)}, ${getSliderValue('lightZ').toFixed(3)})
#define uAmbient ${getSliderValue('ambient').toFixed(3)}
#define uDiffuse ${getSliderValue('diffuse').toFixed(3)}
#define uShadowSoft ${getSliderValue('shadowSoft').toFixed(3)}
#define uObjectColor vec3(${getColorValue('objectColor').r.toFixed(3)}, ${getColorValue('objectColor').g.toFixed(3)}, ${getColorValue('objectColor').b.toFixed(3)})
#define uLightColor vec3(${getColorValue('lightColor').r.toFixed(3)}, ${getColorValue('lightColor').g.toFixed(3)}, ${getColorValue('lightColor').b.toFixed(3)})
#define uAmbientColor vec3(${getColorValue('ambientColor').r.toFixed(3)}, ${getColorValue('ambientColor').g.toFixed(3)}, ${getColorValue('ambientColor').b.toFixed(3)})
#define uBgColor vec3(${getColorValue('bgColor').r.toFixed(3)}, ${getColorValue('bgColor').g.toFixed(3)}, ${getColorValue('bgColor').b.toFixed(3)})

`;

            const fullCode = defines + shaderCode;

            document.getElementById('exportCode').textContent = fullCode;
            document.getElementById('exportModal').classList.add('active');
        }

        // ============================================
        // RENDER LOOP
        // ============================================

        function render() {
            const now = performance.now();
            const delta = (now - lastTime) / 1000;
            lastTime = now;

            if (!paused) {
                time += delta;
            }

            // FPS counter
            frameCount++;
            if (frameCount >= 30) {
                fps = Math.round(frameCount / delta / 30);
                document.getElementById('fpsCounter').textContent = fps + ' FPS';
                frameCount = 0;
            }

            if (!program) {
                requestAnimationFrame(render);
                return;
            }

            // Set uniforms
            gl.uniform2f(gl.getUniformLocation(program, 'iResolution'), canvas.width, canvas.height);
            gl.uniform1f(gl.getUniformLocation(program, 'iTime'), time);
            gl.uniform4f(gl.getUniformLocation(program, 'iMouse'), mouseX, mouseY, mouseDown, 0);

            // Custom uniforms
            gl.uniform1f(gl.getUniformLocation(program, 'uSpeed'), getSliderValue('speed'));
            gl.uniform1f(gl.getUniformLocation(program, 'uTimeOffset'), getSliderValue('timeOffset'));
            gl.uniform1f(gl.getUniformLocation(program, 'uZoom'), getSliderValue('zoom'));
            gl.uniform1f(gl.getUniformLocation(program, 'uFov'), getSliderValue('fov'));
            gl.uniform1f(gl.getUniformLocation(program, 'uCamHeight'), getSliderValue('camHeight'));
            gl.uniform1f(gl.getUniformLocation(program, 'uSpikeLength'), getSliderValue('spikeLength'));
            gl.uniform1f(gl.getUniformLocation(program, 'uSpikeWidth'), getSliderValue('spikeWidth'));
            gl.uniform1f(gl.getUniformLocation(program, 'uShellThickness'), getSliderValue('shellThickness'));
            gl.uniform1f(gl.getUniformLocation(program, 'uSphereRadius'), getSliderValue('sphereRadius'));
            gl.uniform1f(gl.getUniformLocation(program, 'uSmoothing'), getSliderValue('smoothing'));

            const lightDir = [getSliderValue('lightX'), getSliderValue('lightY'), getSliderValue('lightZ')];
            gl.uniform3fv(gl.getUniformLocation(program, 'uLightDir'), lightDir);
            gl.uniform1f(gl.getUniformLocation(program, 'uAmbient'), getSliderValue('ambient'));
            gl.uniform1f(gl.getUniformLocation(program, 'uDiffuse'), getSliderValue('diffuse'));
            gl.uniform1f(gl.getUniformLocation(program, 'uShadowSoft'), getSliderValue('shadowSoft'));

            const objCol = getColorValue('objectColor');
            const lightCol = getColorValue('lightColor');
            const ambCol = getColorValue('ambientColor');
            const bgCol = getColorValue('bgColor');

            gl.uniform3f(gl.getUniformLocation(program, 'uObjectColor'), objCol.r, objCol.g, objCol.b);
            gl.uniform3f(gl.getUniformLocation(program, 'uLightColor'), lightCol.r, lightCol.g, lightCol.b);
            gl.uniform3f(gl.getUniformLocation(program, 'uAmbientColor'), ambCol.r, ambCol.g, ambCol.b);
            gl.uniform3f(gl.getUniformLocation(program, 'uBgColor'), bgCol.r, bgCol.g, bgCol.b);

            // Draw
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        // ============================================
        // INIT
        // ============================================

        initWebGL();
        setupSliderListeners();
        setupEventListeners();
        updatePresetButtonStates();
        applyPreset(0);
        render();
    </script>
</body>
</html>
